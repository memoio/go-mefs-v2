// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fs.proto

package pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// kv key type
type MetaType int32

const (
	MetaType_Unknown      MetaType = 0
	MetaType_LocalNetKey  MetaType = 1
	MetaType_LocalAddrKey MetaType = 2
	MetaType_RoleInfoKey  MetaType = 3
	MetaType_NetInfoKey   MetaType = 4
	MetaType_PDPProveKey  MetaType = 5
	MetaType_PDPVerifyKey MetaType = 6
	MetaType_FsMemberKey  MetaType = 7
	// lfs meta
	MetaType_LFS_SuperBlockInfoKey MetaType = 10
	MetaType_LFS_BucketInfoKey     MetaType = 11
	MetaType_LFS_ObjectInfoKey     MetaType = 12
	MetaType_LFS_BucketOptionKey   MetaType = 13
	MetaType_LFS_OpInfoKey         MetaType = 14
	MetaType_LFS_OpDoneKey         MetaType = 16
	MetaType_LFS_OpCountKey        MetaType = 17
	// key in state tree
	MetaType_ST_GasMoneyKey   MetaType = 20
	MetaType_ST_RoleInfoKey   MetaType = 21
	MetaType_ST_BucketOptKey  MetaType = 23
	MetaType_ST_SegLocKey     MetaType = 24
	MetaType_ST_SegExpireKey  MetaType = 25
	MetaType_ST_PieceLocKey   MetaType = 26
	MetaType_ST_SectorInfoKey MetaType = 27
	MetaType_ST_DataOrderKey  MetaType = 30
	MetaType_ST_EpochKey      MetaType = 31
	//ST_ChalSeedKey = 32;     // key: x/epoch; val: height, seed, time
	MetaType_ST_IncomeKey     MetaType = 33
	MetaType_ST_ChalSegResKey MetaType = 34
	MetaType_ST_ChalSecResKey MetaType = 35
	// data meta
	MetaType_PieceInfoKey    MetaType = 40
	MetaType_SectorPiecesKey MetaType = 41
	MetaType_SectorCountKey  MetaType = 42
	MetaType_SectorSetKey    MetaType = 43
	MetaType_OrderTxKey      MetaType = 44
	// order
	MetaType_OrderNonceKey      MetaType = 50
	MetaType_OrderBaseKey       MetaType = 51
	MetaType_OrderSeqKey        MetaType = 52
	MetaType_TX_MessageKey      MetaType = 60
	MetaType_Tx_MessageStateKey MetaType = 61
	MetaType_TX_BlockKey        MetaType = 62
	MetaType_Tx_HeightKey       MetaType = 63
)

var MetaType_name = map[int32]string{
	0:  "Unknown",
	1:  "LocalNetKey",
	2:  "LocalAddrKey",
	3:  "RoleInfoKey",
	4:  "NetInfoKey",
	5:  "PDPProveKey",
	6:  "PDPVerifyKey",
	7:  "FsMemberKey",
	10: "LFS_SuperBlockInfoKey",
	11: "LFS_BucketInfoKey",
	12: "LFS_ObjectInfoKey",
	13: "LFS_BucketOptionKey",
	14: "LFS_OpInfoKey",
	16: "LFS_OpDoneKey",
	17: "LFS_OpCountKey",
	20: "ST_GasMoneyKey",
	21: "ST_RoleInfoKey",
	23: "ST_BucketOptKey",
	24: "ST_SegLocKey",
	25: "ST_SegExpireKey",
	26: "ST_PieceLocKey",
	27: "ST_SectorInfoKey",
	30: "ST_DataOrderKey",
	31: "ST_EpochKey",
	33: "ST_IncomeKey",
	34: "ST_ChalSegResKey",
	35: "ST_ChalSecResKey",
	40: "PieceInfoKey",
	41: "SectorPiecesKey",
	42: "SectorCountKey",
	43: "SectorSetKey",
	44: "OrderTxKey",
	50: "OrderNonceKey",
	51: "OrderBaseKey",
	52: "OrderSeqKey",
	60: "TX_MessageKey",
	61: "Tx_MessageStateKey",
	62: "TX_BlockKey",
	63: "Tx_HeightKey",
}

var MetaType_value = map[string]int32{
	"Unknown":               0,
	"LocalNetKey":           1,
	"LocalAddrKey":          2,
	"RoleInfoKey":           3,
	"NetInfoKey":            4,
	"PDPProveKey":           5,
	"PDPVerifyKey":          6,
	"FsMemberKey":           7,
	"LFS_SuperBlockInfoKey": 10,
	"LFS_BucketInfoKey":     11,
	"LFS_ObjectInfoKey":     12,
	"LFS_BucketOptionKey":   13,
	"LFS_OpInfoKey":         14,
	"LFS_OpDoneKey":         16,
	"LFS_OpCountKey":        17,
	"ST_GasMoneyKey":        20,
	"ST_RoleInfoKey":        21,
	"ST_BucketOptKey":       23,
	"ST_SegLocKey":          24,
	"ST_SegExpireKey":       25,
	"ST_PieceLocKey":        26,
	"ST_SectorInfoKey":      27,
	"ST_DataOrderKey":       30,
	"ST_EpochKey":           31,
	"ST_IncomeKey":          33,
	"ST_ChalSegResKey":      34,
	"ST_ChalSecResKey":      35,
	"PieceInfoKey":          40,
	"SectorPiecesKey":       41,
	"SectorCountKey":        42,
	"SectorSetKey":          43,
	"OrderTxKey":            44,
	"OrderNonceKey":         50,
	"OrderBaseKey":          51,
	"OrderSeqKey":           52,
	"TX_MessageKey":         60,
	"Tx_MessageStateKey":    61,
	"TX_BlockKey":           62,
	"Tx_HeightKey":          63,
}

func (x MetaType) String() string {
	return proto.EnumName(MetaType_name, int32(x))
}

func (MetaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{0}
}

type DataType int32

const (
	DataType_DataErr DataType = 0
	DataType_Segment DataType = 1
	DataType_Piece   DataType = 2
	DataType_Sector  DataType = 3
)

var DataType_name = map[int32]string{
	0: "DataErr",
	1: "Segment",
	2: "Piece",
	3: "Sector",
}

var DataType_value = map[string]int32{
	"DataErr": 0,
	"Segment": 1,
	"Piece":   2,
	"Sector":  3,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{1}
}

type OpRecord_OpType int32

const (
	OpRecord_Unknown      OpRecord_OpType = 0
	OpRecord_CreateObject OpRecord_OpType = 1
	OpRecord_AddData      OpRecord_OpType = 2
	OpRecord_DeleteObject OpRecord_OpType = 3
)

var OpRecord_OpType_name = map[int32]string{
	0: "Unknown",
	1: "CreateObject",
	2: "AddData",
	3: "DeleteObject",
}

var OpRecord_OpType_value = map[string]int32{
	"Unknown":      0,
	"CreateObject": 1,
	"AddData":      2,
	"DeleteObject": 3,
}

func (x OpRecord_OpType) String() string {
	return proto.EnumName(OpRecord_OpType_name, int32(x))
}

func (OpRecord_OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{7, 0}
}

// 'SuperBlockInfoKey'/fsID
type SuperBlockInfo struct {
	Version              uint32   `protobuf:"varint,1,opt,name=Version,json=version,proto3" json:"Version,omitempty"`
	ReplicaNum           uint32   `protobuf:"varint,2,opt,name=ReplicaNum,json=replicaNum,proto3" json:"ReplicaNum,omitempty"`
	NextBucketID         uint64   `protobuf:"varint,3,opt,name=NextBucketID,json=nextBucketID,proto3" json:"NextBucketID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SuperBlockInfo) Reset()         { *m = SuperBlockInfo{} }
func (m *SuperBlockInfo) String() string { return proto.CompactTextString(m) }
func (*SuperBlockInfo) ProtoMessage()    {}
func (*SuperBlockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{0}
}
func (m *SuperBlockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuperBlockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuperBlockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuperBlockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuperBlockInfo.Merge(m, src)
}
func (m *SuperBlockInfo) XXX_Size() int {
	return m.Size()
}
func (m *SuperBlockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SuperBlockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SuperBlockInfo proto.InternalMessageInfo

func (m *SuperBlockInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SuperBlockInfo) GetReplicaNum() uint32 {
	if m != nil {
		return m.ReplicaNum
	}
	return 0
}

func (m *SuperBlockInfo) GetNextBucketID() uint64 {
	if m != nil {
		return m.NextBucketID
	}
	return 0
}

// 'BucketCountKey'/fsID
// 'StripeCountKey'/fsID/bucketID
// key: 'BucketOptionKey'/fsID/bucketID
type BucketOption struct {
	Version              uint32   `protobuf:"varint,1,opt,name=Version,json=version,proto3" json:"Version,omitempty"`
	Policy               uint32   `protobuf:"varint,2,opt,name=Policy,json=policy,proto3" json:"Policy,omitempty"`
	DataCount            uint32   `protobuf:"varint,3,opt,name=DataCount,json=dataCount,proto3" json:"DataCount,omitempty"`
	ParityCount          uint32   `protobuf:"varint,4,opt,name=ParityCount,json=parityCount,proto3" json:"ParityCount,omitempty"`
	TagFlag              uint32   `protobuf:"varint,5,opt,name=TagFlag,json=tagFlag,proto3" json:"TagFlag,omitempty"`
	SegSize              uint32   `protobuf:"varint,6,opt,name=SegSize,json=segSize,proto3" json:"SegSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BucketOption) Reset()         { *m = BucketOption{} }
func (m *BucketOption) String() string { return proto.CompactTextString(m) }
func (*BucketOption) ProtoMessage()    {}
func (*BucketOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{1}
}
func (m *BucketOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketOption.Merge(m, src)
}
func (m *BucketOption) XXX_Size() int {
	return m.Size()
}
func (m *BucketOption) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketOption.DiscardUnknown(m)
}

var xxx_messageInfo_BucketOption proto.InternalMessageInfo

func (m *BucketOption) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BucketOption) GetPolicy() uint32 {
	if m != nil {
		return m.Policy
	}
	return 0
}

func (m *BucketOption) GetDataCount() uint32 {
	if m != nil {
		return m.DataCount
	}
	return 0
}

func (m *BucketOption) GetParityCount() uint32 {
	if m != nil {
		return m.ParityCount
	}
	return 0
}

func (m *BucketOption) GetTagFlag() uint32 {
	if m != nil {
		return m.TagFlag
	}
	return 0
}

func (m *BucketOption) GetSegSize() uint32 {
	if m != nil {
		return m.SegSize
	}
	return 0
}

// key: 'BucketInfoKey'/fsID/bucketID
type BucketInfo struct {
	BucketID             uint64   `protobuf:"varint,1,opt,name=BucketID,json=bucketID,proto3" json:"BucketID,omitempty"`
	CTime                int64    `protobuf:"varint,2,opt,name=CTime,json=cTime,proto3" json:"CTime,omitempty"`
	MTime                int64    `protobuf:"varint,3,opt,name=MTime,json=mTime,proto3" json:"MTime,omitempty"`
	Length               uint64   `protobuf:"varint,4,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	UsedBytes            uint64   `protobuf:"varint,5,opt,name=UsedBytes,json=usedBytes,proto3" json:"UsedBytes,omitempty"`
	NextObjectID         uint64   `protobuf:"varint,6,opt,name=NextObjectID,json=nextObjectID,proto3" json:"NextObjectID,omitempty"`
	NextOpID             uint64   `protobuf:"varint,7,opt,name=NextOpID,json=nextOpID,proto3" json:"NextOpID,omitempty"`
	Deletion             bool     `protobuf:"varint,8,opt,name=deletion,proto3" json:"deletion,omitempty"`
	Name                 string   `protobuf:"bytes,9,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
	Root                 []byte   `protobuf:"bytes,10,opt,name=Root,json=root,proto3" json:"Root,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BucketInfo) Reset()         { *m = BucketInfo{} }
func (m *BucketInfo) String() string { return proto.CompactTextString(m) }
func (*BucketInfo) ProtoMessage()    {}
func (*BucketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{2}
}
func (m *BucketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketInfo.Merge(m, src)
}
func (m *BucketInfo) XXX_Size() int {
	return m.Size()
}
func (m *BucketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BucketInfo proto.InternalMessageInfo

func (m *BucketInfo) GetBucketID() uint64 {
	if m != nil {
		return m.BucketID
	}
	return 0
}

func (m *BucketInfo) GetCTime() int64 {
	if m != nil {
		return m.CTime
	}
	return 0
}

func (m *BucketInfo) GetMTime() int64 {
	if m != nil {
		return m.MTime
	}
	return 0
}

func (m *BucketInfo) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *BucketInfo) GetUsedBytes() uint64 {
	if m != nil {
		return m.UsedBytes
	}
	return 0
}

func (m *BucketInfo) GetNextObjectID() uint64 {
	if m != nil {
		return m.NextObjectID
	}
	return 0
}

func (m *BucketInfo) GetNextOpID() uint64 {
	if m != nil {
		return m.NextOpID
	}
	return 0
}

func (m *BucketInfo) GetDeletion() bool {
	if m != nil {
		return m.Deletion
	}
	return false
}

func (m *BucketInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BucketInfo) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

type ObjectForm struct {
	OpRecord             []uint64 `protobuf:"varint,1,rep,packed,name=OpRecord,json=opRecord,proto3" json:"OpRecord,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectForm) Reset()         { *m = ObjectForm{} }
func (m *ObjectForm) String() string { return proto.CompactTextString(m) }
func (*ObjectForm) ProtoMessage()    {}
func (*ObjectForm) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{3}
}
func (m *ObjectForm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectForm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectForm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectForm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectForm.Merge(m, src)
}
func (m *ObjectForm) XXX_Size() int {
	return m.Size()
}
func (m *ObjectForm) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectForm.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectForm proto.InternalMessageInfo

func (m *ObjectForm) GetOpRecord() []uint64 {
	if m != nil {
		return m.OpRecord
	}
	return nil
}

// object information; when create object
type ObjectInfo struct {
	ObjectID             uint64   `protobuf:"varint,1,opt,name=ObjectID,json=objectID,proto3" json:"ObjectID,omitempty"`
	BucketID             uint64   `protobuf:"varint,2,opt,name=BucketID,json=bucketID,proto3" json:"BucketID,omitempty"`
	Time                 int64    `protobuf:"varint,3,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Expire               uint64   `protobuf:"varint,4,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	Name                 string   `protobuf:"bytes,5,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
	Encryption           string   `protobuf:"bytes,6,opt,name=Encryption,json=encryption,proto3" json:"Encryption,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectInfo) Reset()         { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()    {}
func (*ObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{4}
}
func (m *ObjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectInfo.Merge(m, src)
}
func (m *ObjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectInfo proto.InternalMessageInfo

func (m *ObjectInfo) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *ObjectInfo) GetBucketID() uint64 {
	if m != nil {
		return m.BucketID
	}
	return 0
}

func (m *ObjectInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ObjectInfo) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *ObjectInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectInfo) GetEncryption() string {
	if m != nil {
		return m.Encryption
	}
	return ""
}

// object delete information; when delete object
type ObjectDeleteInfo struct {
	ObjectID             uint64   `protobuf:"varint,1,opt,name=ObjectID,json=objectID,proto3" json:"ObjectID,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectDeleteInfo) Reset()         { *m = ObjectDeleteInfo{} }
func (m *ObjectDeleteInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectDeleteInfo) ProtoMessage()    {}
func (*ObjectDeleteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{5}
}
func (m *ObjectDeleteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectDeleteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectDeleteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectDeleteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectDeleteInfo.Merge(m, src)
}
func (m *ObjectDeleteInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectDeleteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectDeleteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectDeleteInfo proto.InternalMessageInfo

func (m *ObjectDeleteInfo) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *ObjectDeleteInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// opart informations, insert into object when add data to an existing object
type ObjectPartInfo struct {
	ObjectID             uint64   `protobuf:"varint,1,opt,name=ObjectID,json=objectID,proto3" json:"ObjectID,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Offset               uint64   `protobuf:"varint,3,opt,name=Offset,json=offset,proto3" json:"Offset,omitempty"`
	Length               uint64   `protobuf:"varint,4,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	RawLength            uint64   `protobuf:"varint,5,opt,name=RawLength,json=rawLength,proto3" json:"RawLength,omitempty"`
	ETag                 []byte   `protobuf:"bytes,7,opt,name=ETag,json=eTag,proto3" json:"ETag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectPartInfo) Reset()         { *m = ObjectPartInfo{} }
func (m *ObjectPartInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectPartInfo) ProtoMessage()    {}
func (*ObjectPartInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{6}
}
func (m *ObjectPartInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectPartInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectPartInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectPartInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectPartInfo.Merge(m, src)
}
func (m *ObjectPartInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectPartInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectPartInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectPartInfo proto.InternalMessageInfo

func (m *ObjectPartInfo) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *ObjectPartInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ObjectPartInfo) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ObjectPartInfo) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *ObjectPartInfo) GetRawLength() uint64 {
	if m != nil {
		return m.RawLength
	}
	return 0
}

func (m *ObjectPartInfo) GetETag() []byte {
	if m != nil {
		return m.ETag
	}
	return nil
}

// 'OpDoneKey'/fsID/bucketID
// 'OpCountKey'/fsID/bucketID
// key: 'OpInfoKey'/fsID/bucketID/opID
type OpRecord struct {
	Type                 OpRecord_OpType `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=pb.OpRecord_OpType" json:"Type,omitempty"`
	OpID                 uint64          `protobuf:"varint,2,opt,name=OpID,json=opID,proto3" json:"OpID,omitempty"`
	Time                 int64           `protobuf:"varint,3,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Payload              []byte          `protobuf:"bytes,4,opt,name=Payload,json=payload,proto3" json:"Payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *OpRecord) Reset()         { *m = OpRecord{} }
func (m *OpRecord) String() string { return proto.CompactTextString(m) }
func (*OpRecord) ProtoMessage()    {}
func (*OpRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{7}
}
func (m *OpRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpRecord.Merge(m, src)
}
func (m *OpRecord) XXX_Size() int {
	return m.Size()
}
func (m *OpRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_OpRecord.DiscardUnknown(m)
}

var xxx_messageInfo_OpRecord proto.InternalMessageInfo

func (m *OpRecord) GetType() OpRecord_OpType {
	if m != nil {
		return m.Type
	}
	return OpRecord_Unknown
}

func (m *OpRecord) GetOpID() uint64 {
	if m != nil {
		return m.OpID
	}
	return 0
}

func (m *OpRecord) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *OpRecord) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// key: 'SegLocKey'/fsID_bucketID_chunkID_stripeID
type SegLocation struct {
	Expire               uint64   `protobuf:"varint,1,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	Length               uint64   `protobuf:"varint,2,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	ProID                uint64   `protobuf:"varint,3,opt,name=ProID,json=proID,proto3" json:"ProID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SegLocation) Reset()         { *m = SegLocation{} }
func (m *SegLocation) String() string { return proto.CompactTextString(m) }
func (*SegLocation) ProtoMessage()    {}
func (*SegLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{8}
}
func (m *SegLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegLocation.Merge(m, src)
}
func (m *SegLocation) XXX_Size() int {
	return m.Size()
}
func (m *SegLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_SegLocation.DiscardUnknown(m)
}

var xxx_messageInfo_SegLocation proto.InternalMessageInfo

func (m *SegLocation) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *SegLocation) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SegLocation) GetProID() uint64 {
	if m != nil {
		return m.ProID
	}
	return 0
}

// key: 'SegExpireKey'/fsID_bucketID_stripeID
type SegExpire struct {
	Length               uint64   `protobuf:"varint,1,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	Expire               uint64   `protobuf:"varint,2,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SegExpire) Reset()         { *m = SegExpire{} }
func (m *SegExpire) String() string { return proto.CompactTextString(m) }
func (*SegExpire) ProtoMessage()    {}
func (*SegExpire) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{9}
}
func (m *SegExpire) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegExpire) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegExpire.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegExpire) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegExpire.Merge(m, src)
}
func (m *SegExpire) XXX_Size() int {
	return m.Size()
}
func (m *SegExpire) XXX_DiscardUnknown() {
	xxx_messageInfo_SegExpire.DiscardUnknown(m)
}

var xxx_messageInfo_SegExpire proto.InternalMessageInfo

func (m *SegExpire) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SegExpire) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

// key: 'PieceLocKey'/pieceID; on keeper and user
type PieceLocation struct {
	Size_                uint32   `protobuf:"varint,1,opt,name=Size,json=size,proto3" json:"Size,omitempty"`
	Expire               uint64   `protobuf:"varint,2,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	ProID                []uint64 `protobuf:"varint,3,rep,packed,name=ProID,json=proID,proto3" json:"ProID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PieceLocation) Reset()         { *m = PieceLocation{} }
func (m *PieceLocation) String() string { return proto.CompactTextString(m) }
func (*PieceLocation) ProtoMessage()    {}
func (*PieceLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{10}
}
func (m *PieceLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PieceLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PieceLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PieceLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceLocation.Merge(m, src)
}
func (m *PieceLocation) XXX_Size() int {
	return m.Size()
}
func (m *PieceLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceLocation.DiscardUnknown(m)
}

var xxx_messageInfo_PieceLocation proto.InternalMessageInfo

func (m *PieceLocation) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *PieceLocation) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *PieceLocation) GetProID() []uint64 {
	if m != nil {
		return m.ProID
	}
	return nil
}

// fsID need?
// key: 'PieceInfoKey'/pieceID; on provider
type PieceInfo struct {
	Offset               uint32   `protobuf:"varint,1,opt,name=Offset,json=offset,proto3" json:"Offset,omitempty"`
	Size_                uint32   `protobuf:"varint,2,opt,name=Size,json=size,proto3" json:"Size,omitempty"`
	Expire               uint64   `protobuf:"varint,3,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	SectorID             uint64   `protobuf:"varint,4,opt,name=SectorID,json=sectorID,proto3" json:"SectorID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PieceInfo) Reset()         { *m = PieceInfo{} }
func (m *PieceInfo) String() string { return proto.CompactTextString(m) }
func (*PieceInfo) ProtoMessage()    {}
func (*PieceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{11}
}
func (m *PieceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PieceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PieceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PieceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceInfo.Merge(m, src)
}
func (m *PieceInfo) XXX_Size() int {
	return m.Size()
}
func (m *PieceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PieceInfo proto.InternalMessageInfo

func (m *PieceInfo) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PieceInfo) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *PieceInfo) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *PieceInfo) GetSectorID() uint64 {
	if m != nil {
		return m.SectorID
	}
	return 0
}

// 'SectorCountKey'/proID; on keeper and provider
// 'SectorSetKey'/proID; on keeper and provider
// key: 'SectorInfoKey'/pieceID; on keeper, 70 bytes
type SectorInfo struct {
	Expire               uint64   `protobuf:"varint,1,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	CommD                []byte   `protobuf:"bytes,2,opt,name=CommD,json=commD,proto3" json:"CommD,omitempty"`
	CommR                []byte   `protobuf:"bytes,3,opt,name=CommR,json=commR,proto3" json:"CommR,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SectorInfo) Reset()         { *m = SectorInfo{} }
func (m *SectorInfo) String() string { return proto.CompactTextString(m) }
func (*SectorInfo) ProtoMessage()    {}
func (*SectorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{12}
}
func (m *SectorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SectorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SectorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SectorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SectorInfo.Merge(m, src)
}
func (m *SectorInfo) XXX_Size() int {
	return m.Size()
}
func (m *SectorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SectorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SectorInfo proto.InternalMessageInfo

func (m *SectorInfo) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *SectorInfo) GetCommD() []byte {
	if m != nil {
		return m.CommD
	}
	return nil
}

func (m *SectorInfo) GetCommR() []byte {
	if m != nil {
		return m.CommR
	}
	return nil
}

// key: 'SectorPiecesKey'/sectorID; on provider
type SectorPieces struct {
	Sector               *SectorInfo `protobuf:"bytes,1,opt,name=Sector,json=sector,proto3" json:"Sector,omitempty"`
	PieceID              [][]byte    `protobuf:"bytes,2,rep,name=PieceID,json=pieceID,proto3" json:"PieceID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SectorPieces) Reset()         { *m = SectorPieces{} }
func (m *SectorPieces) String() string { return proto.CompactTextString(m) }
func (*SectorPieces) ProtoMessage()    {}
func (*SectorPieces) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{13}
}
func (m *SectorPieces) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SectorPieces) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SectorPieces.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SectorPieces) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SectorPieces.Merge(m, src)
}
func (m *SectorPieces) XXX_Size() int {
	return m.Size()
}
func (m *SectorPieces) XXX_DiscardUnknown() {
	xxx_messageInfo_SectorPieces.DiscardUnknown(m)
}

var xxx_messageInfo_SectorPieces proto.InternalMessageInfo

func (m *SectorPieces) GetSector() *SectorInfo {
	if m != nil {
		return m.Sector
	}
	return nil
}

func (m *SectorPieces) GetPieceID() [][]byte {
	if m != nil {
		return m.PieceID
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.MetaType", MetaType_name, MetaType_value)
	proto.RegisterEnum("pb.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("pb.OpRecord_OpType", OpRecord_OpType_name, OpRecord_OpType_value)
	proto.RegisterType((*SuperBlockInfo)(nil), "pb.SuperBlockInfo")
	proto.RegisterType((*BucketOption)(nil), "pb.BucketOption")
	proto.RegisterType((*BucketInfo)(nil), "pb.BucketInfo")
	proto.RegisterType((*ObjectForm)(nil), "pb.ObjectForm")
	proto.RegisterType((*ObjectInfo)(nil), "pb.ObjectInfo")
	proto.RegisterType((*ObjectDeleteInfo)(nil), "pb.ObjectDeleteInfo")
	proto.RegisterType((*ObjectPartInfo)(nil), "pb.ObjectPartInfo")
	proto.RegisterType((*OpRecord)(nil), "pb.OpRecord")
	proto.RegisterType((*SegLocation)(nil), "pb.SegLocation")
	proto.RegisterType((*SegExpire)(nil), "pb.SegExpire")
	proto.RegisterType((*PieceLocation)(nil), "pb.PieceLocation")
	proto.RegisterType((*PieceInfo)(nil), "pb.PieceInfo")
	proto.RegisterType((*SectorInfo)(nil), "pb.SectorInfo")
	proto.RegisterType((*SectorPieces)(nil), "pb.SectorPieces")
}

func init() { proto.RegisterFile("fs.proto", fileDescriptor_e604833c2b457e38) }

var fileDescriptor_e604833c2b457e38 = []byte{
	// 1199 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0xcf, 0x92, 0xdb, 0xc4,
	0x13, 0xc7, 0x23, 0x5b, 0x96, 0xed, 0xb6, 0xd7, 0x51, 0x26, 0x9b, 0x44, 0xc9, 0xef, 0x57, 0xc6,
	0x88, 0x2a, 0x30, 0x81, 0xda, 0x43, 0xc2, 0x2d, 0xfc, 0xa9, 0x78, 0xed, 0x85, 0x2d, 0xb2, 0xb6,
	0x90, 0x94, 0x54, 0x6e, 0x2e, 0x59, 0x9e, 0xd5, 0x9a, 0xb5, 0x35, 0x42, 0xd2, 0x26, 0xeb, 0x3c,
	0x04, 0x67, 0xce, 0x14, 0x8f, 0xc0, 0x95, 0x3b, 0x47, 0x1e, 0x81, 0x0a, 0xef, 0x41, 0x51, 0xdd,
	0x33, 0xb2, 0xec, 0x90, 0x85, 0x2a, 0x6e, 0xee, 0x4f, 0xcf, 0xf4, 0x9f, 0xef, 0xf4, 0x8c, 0x0c,
	0x8d, 0xd3, 0xec, 0x20, 0x49, 0x45, 0x2e, 0x58, 0x25, 0x99, 0xd9, 0x31, 0x74, 0xbc, 0x8b, 0x84,
	0xa7, 0x83, 0xa5, 0x08, 0xcf, 0x8f, 0xe3, 0x53, 0xc1, 0x2c, 0xa8, 0x3f, 0xe3, 0x69, 0xb6, 0x10,
	0xb1, 0xa5, 0xf5, 0xb4, 0xfe, 0x9e, 0x5b, 0x7f, 0x21, 0x4d, 0xd6, 0x05, 0x70, 0x79, 0xb2, 0x5c,
	0x84, 0xc1, 0xf8, 0x62, 0x65, 0x55, 0xc8, 0x09, 0xe9, 0x86, 0x30, 0x1b, 0xda, 0x63, 0x7e, 0x99,
	0x0f, 0x2e, 0xc2, 0x73, 0x9e, 0x1f, 0x0f, 0xad, 0x6a, 0x4f, 0xeb, 0xeb, 0x6e, 0x3b, 0xde, 0x62,
	0xf6, 0xcf, 0x1a, 0xb4, 0xa5, 0x31, 0x49, 0x72, 0x0c, 0x7a, 0x75, 0xba, 0xdb, 0x60, 0x38, 0x62,
	0xb9, 0x08, 0xd7, 0x2a, 0x95, 0x91, 0x90, 0xc5, 0xfe, 0x0f, 0xcd, 0x61, 0x90, 0x07, 0x87, 0xe2,
	0x22, 0xce, 0x29, 0xc7, 0x9e, 0xdb, 0x9c, 0x17, 0x80, 0xf5, 0xa0, 0xe5, 0x04, 0xe9, 0x22, 0x5f,
	0x4b, 0xbf, 0x4e, 0xfe, 0x56, 0x52, 0x22, 0xcc, 0xe8, 0x07, 0xd1, 0xd1, 0x32, 0x88, 0xac, 0x9a,
	0xcc, 0x98, 0x4b, 0x13, 0x3d, 0x1e, 0x8f, 0xbc, 0xc5, 0x2b, 0x6e, 0x19, 0xd2, 0x93, 0x49, 0xd3,
	0xfe, 0xbe, 0x02, 0xa0, 0x7a, 0x40, 0x8d, 0xee, 0x41, 0x63, 0xd3, 0xa5, 0x46, 0x5d, 0x36, 0x66,
	0xca, 0x66, 0xfb, 0x50, 0x3b, 0xf4, 0x17, 0x2b, 0x4e, 0x55, 0x57, 0xdd, 0x5a, 0x88, 0x06, 0xd2,
	0x13, 0xa2, 0x55, 0x49, 0x57, 0x44, 0x6f, 0x83, 0xf1, 0x84, 0xc7, 0x51, 0x7e, 0x46, 0x75, 0xea,
	0xae, 0xb1, 0x24, 0x0b, 0x5b, 0x7c, 0x9a, 0xf1, 0xf9, 0x60, 0x9d, 0xf3, 0x8c, 0x8a, 0xd4, 0xdd,
	0xe6, 0x45, 0x01, 0x0a, 0x9d, 0x27, 0xb3, 0x6f, 0x79, 0x88, 0x15, 0x18, 0xa5, 0xce, 0x05, 0xc3,
	0x0a, 0x69, 0x4d, 0x72, 0x3c, 0xb4, 0xea, 0xb2, 0xc2, 0x58, 0xd9, 0xe8, 0x9b, 0xf3, 0x25, 0x47,
	0xf9, 0xad, 0x46, 0x4f, 0xeb, 0x37, 0xdc, 0x8d, 0xcd, 0x18, 0xe8, 0xe3, 0x60, 0xc5, 0xad, 0x66,
	0x4f, 0xeb, 0x37, 0x5d, 0x3d, 0x0e, 0x56, 0x1c, 0x99, 0x2b, 0x44, 0x6e, 0x41, 0x4f, 0xeb, 0xb7,
	0x5d, 0x3d, 0x15, 0x22, 0xb7, 0xfb, 0x00, 0x32, 0xd7, 0x91, 0x48, 0x57, 0x18, 0x71, 0x92, 0xb8,
	0x3c, 0x14, 0xe9, 0xdc, 0xd2, 0x7a, 0x55, 0xcc, 0x26, 0x94, 0x6d, 0xff, 0xa4, 0x15, 0x4b, 0x0b,
	0xe9, 0x36, 0x85, 0x2b, 0xe9, 0xc4, 0x56, 0xd1, 0x1b, 0x59, 0x2b, 0x6f, 0xc8, 0xca, 0x40, 0xdf,
	0xd2, 0x4f, 0xcf, 0x95, 0x7c, 0xa3, 0xcb, 0x64, 0x91, 0xf2, 0x42, 0x3e, 0x4e, 0xd6, 0xa6, 0x89,
	0xda, 0x56, 0x13, 0x5d, 0x80, 0x51, 0x1c, 0xa6, 0x6b, 0x9a, 0x3a, 0x92, 0xac, 0xe9, 0x02, 0xdf,
	0x10, 0x7b, 0x00, 0xa6, 0xac, 0x6b, 0x88, 0x52, 0xf0, 0x7f, 0xad, 0xb5, 0xa8, 0xa7, 0x52, 0xd6,
	0x63, 0xff, 0xa8, 0x41, 0x47, 0x6e, 0x70, 0x82, 0x34, 0xff, 0x2f, 0x21, 0xb0, 0xa5, 0xc9, 0xe9,
	0x69, 0xc6, 0x73, 0x75, 0x7b, 0x0c, 0x41, 0xd6, 0x3f, 0x4d, 0x8a, 0x1b, 0xbc, 0x54, 0x2e, 0x35,
	0x29, 0x69, 0x01, 0x30, 0xc3, 0xc8, 0x0f, 0x22, 0x9a, 0x80, 0xb6, 0xab, 0x73, 0x3f, 0x88, 0xec,
	0x5f, 0xb4, 0xf2, 0xb0, 0xd8, 0x07, 0xa0, 0xfb, 0xeb, 0x84, 0x53, 0x69, 0x9d, 0x07, 0x37, 0x0f,
	0x92, 0xd9, 0x41, 0xe1, 0x3b, 0x98, 0x24, 0xe8, 0x72, 0xf5, 0x7c, 0x9d, 0x90, 0xa4, 0x34, 0x4b,
	0xf2, 0x58, 0x74, 0x91, 0x5c, 0x71, 0x24, 0x16, 0xd4, 0x9d, 0x60, 0xbd, 0x14, 0xc1, 0x9c, 0x0a,
	0x6d, 0xbb, 0xf5, 0x44, 0x9a, 0xf6, 0x11, 0x18, 0x32, 0x22, 0x6b, 0x41, 0xfd, 0x69, 0x7c, 0x1e,
	0x8b, 0x97, 0xb1, 0x79, 0x8d, 0x99, 0xd0, 0x3e, 0x4c, 0x79, 0x90, 0x73, 0x29, 0x93, 0xa9, 0xa1,
	0xfb, 0xf1, 0x7c, 0x8e, 0x57, 0xdc, 0xac, 0xa0, 0x5b, 0x1e, 0x88, 0x72, 0x57, 0x6d, 0x0f, 0x5a,
	0x1e, 0x8f, 0x9e, 0x88, 0x30, 0xc8, 0xd5, 0x2b, 0xa1, 0x66, 0x40, 0xdb, 0x99, 0x81, 0x52, 0xb0,
	0xca, 0x8e, 0x60, 0xfb, 0x50, 0x73, 0x52, 0xb1, 0x79, 0x9d, 0x6a, 0x09, 0x1a, 0xf6, 0x23, 0x68,
	0x7a, 0x3c, 0x1a, 0xbd, 0xb9, 0x55, 0xdb, 0xd9, 0x5a, 0xa6, 0xaa, 0x6c, 0xa7, 0xb2, 0xbf, 0x81,
	0x3d, 0x67, 0xc1, 0x43, 0xbe, 0xa9, 0x89, 0x81, 0x4e, 0x8f, 0x88, 0x7c, 0xd0, 0xf4, 0x6c, 0xf1,
	0x8a, 0x5f, 0xb5, 0x79, 0xbb, 0x9e, 0x6a, 0x59, 0xcf, 0x39, 0x34, 0x29, 0x24, 0xcd, 0x50, 0x39,
	0x13, 0x32, 0x60, 0x31, 0x13, 0x45, 0x9a, 0xca, 0x5b, 0xd3, 0x54, 0x77, 0xd2, 0xdc, 0x83, 0x86,
	0xc7, 0xc3, 0x5c, 0xa4, 0xc7, 0x43, 0x35, 0x41, 0x8d, 0x4c, 0xd9, 0xb6, 0x03, 0xa0, 0x7c, 0x2a,
	0xdb, 0x5b, 0x05, 0xc5, 0x77, 0x4d, 0xac, 0x56, 0x72, 0x04, 0xda, 0x6e, 0x2d, 0x44, 0xa3, 0xa0,
	0x2e, 0xa5, 0x53, 0xd4, 0xb5, 0x1d, 0x68, 0xcb, 0x88, 0xd4, 0x44, 0xc6, 0xde, 0x07, 0x43, 0xda,
	0x14, 0xb3, 0xf5, 0xa0, 0x83, 0x83, 0x56, 0xe6, 0x74, 0x0d, 0x59, 0x0b, 0x4d, 0x0f, 0xb5, 0x8d,
	0x59, 0xaa, 0x34, 0x3d, 0xd2, 0xbc, 0xff, 0x67, 0x0d, 0x1a, 0x27, 0x3c, 0x0f, 0xfe, 0x3e, 0x40,
	0xd7, 0xa1, 0x85, 0xc2, 0x2f, 0xc7, 0x3c, 0xff, 0x9a, 0xaf, 0x4d, 0x0d, 0x47, 0x86, 0xc0, 0xe3,
	0xf9, 0x3c, 0x45, 0x52, 0xc1, 0x25, 0xae, 0x58, 0x92, 0x98, 0x08, 0xaa, 0xac, 0x03, 0x30, 0x96,
	0x4f, 0x39, 0xda, 0x3a, 0x2e, 0x70, 0x86, 0x8e, 0x93, 0x8a, 0x17, 0x1c, 0x41, 0x0d, 0x63, 0x38,
	0x43, 0xe7, 0x19, 0x4f, 0x17, 0xa7, 0x6b, 0x24, 0x06, 0x2e, 0x39, 0xca, 0x4e, 0xf8, 0x6a, 0xc6,
	0x29, 0x68, 0x9d, 0xdd, 0x85, 0x5b, 0x4f, 0x8e, 0xbc, 0xe9, 0xee, 0xd7, 0x13, 0x5d, 0xc0, 0x6e,
	0xc1, 0x0d, 0x74, 0x95, 0x1f, 0x0c, 0xc4, 0xad, 0x02, 0x97, 0x8f, 0x21, 0xe2, 0x36, 0xbb, 0x03,
	0x37, 0xcb, 0xd5, 0xf2, 0xab, 0x88, 0x8e, 0x3d, 0x76, 0x03, 0xf6, 0x68, 0x7d, 0x52, 0xac, 0xed,
	0x94, 0x68, 0x28, 0x62, 0x2a, 0xd5, 0x64, 0x0c, 0x3a, 0x12, 0xd1, 0xd7, 0x0d, 0xd9, 0x0d, 0x64,
	0x9e, 0x3f, 0xfd, 0x32, 0xc8, 0x4e, 0x44, 0xcc, 0xa9, 0x81, 0x7d, 0xc5, 0xb6, 0x75, 0xb8, 0xc5,
	0x6e, 0xc2, 0x75, 0xcf, 0x2f, 0x33, 0x23, 0xbc, 0x83, 0xbd, 0x7b, 0xfe, 0x54, 0xde, 0x31, 0x24,
	0x96, 0x5a, 0xb6, 0xb9, 0x20, 0x08, 0xef, 0xaa, 0x78, 0xc5, 0xe0, 0x23, 0xbb, 0xc7, 0xf6, 0xc1,
	0xa4, 0x85, 0xc5, 0xc1, 0x22, 0xfd, 0x9f, 0xda, 0x8e, 0x17, 0x7a, 0x92, 0xce, 0xa5, 0x7c, 0x5d,
	0xd4, 0xd3, 0xf3, 0xa7, 0xa3, 0x44, 0x84, 0x67, 0x08, 0xde, 0x51, 0x69, 0x8f, 0xe3, 0x50, 0xac,
	0x28, 0xc3, 0xbb, 0x2a, 0xda, 0xe1, 0x59, 0xb0, 0xf4, 0x78, 0xe4, 0xf2, 0x0c, 0xa9, 0xbd, 0x43,
	0x43, 0x45, 0xdf, 0xa3, 0x03, 0x2b, 0x2e, 0x0c, 0x92, 0x3e, 0x65, 0xdd, 0x9a, 0x41, 0x84, 0x1f,
	0x52, 0xd1, 0x04, 0x37, 0x62, 0xdd, 0xa7, 0xc4, 0xc4, 0x3c, 0x39, 0x41, 0x1f, 0xe1, 0x78, 0x50,
	0xa5, 0xfe, 0x25, 0xda, 0x1f, 0xa3, 0xea, 0x64, 0x8f, 0x45, 0x1c, 0x52, 0x6d, 0x0f, 0x70, 0x13,
	0xa1, 0x41, 0x90, 0x11, 0x79, 0x88, 0x0d, 0x11, 0xf1, 0xf8, 0x77, 0x08, 0x3e, 0xc1, 0x5d, 0xfe,
	0xf3, 0xe9, 0x09, 0xcf, 0xb2, 0x20, 0xa2, 0x35, 0x9f, 0xb2, 0xdb, 0xc0, 0xfc, 0xcb, 0x02, 0x79,
	0x79, 0x90, 0x13, 0xff, 0x0c, 0xf7, 0xfa, 0xcf, 0xa7, 0x34, 0x45, 0x08, 0x3e, 0xc7, 0xf0, 0xfe,
	0xe5, 0xf4, 0x2b, 0xbe, 0x88, 0xce, 0xa8, 0xa6, 0x2f, 0xee, 0x3f, 0x82, 0x06, 0x2a, 0x58, 0xcc,
	0x3f, 0xfe, 0x1e, 0xa5, 0xa9, 0x79, 0x0d, 0x0d, 0x8f, 0x47, 0x2b, 0x1e, 0xe3, 0xdb, 0xd9, 0x84,
	0x1a, 0xb5, 0x6b, 0x56, 0x18, 0x14, 0x77, 0xce, 0xac, 0x0e, 0xcc, 0x5f, 0x5f, 0x77, 0xb5, 0xdf,
	0x5e, 0x77, 0xb5, 0xdf, 0x5f, 0x77, 0xb5, 0x1f, 0xfe, 0xe8, 0x5e, 0x9b, 0x19, 0xf4, 0x17, 0xf0,
	0xe1, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x0b, 0xc0, 0x9c, 0xab, 0x0e, 0x0a, 0x00, 0x00,
}

func (m *SuperBlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuperBlockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuperBlockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NextBucketID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.NextBucketID))
		i--
		dAtA[i] = 0x18
	}
	if m.ReplicaNum != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ReplicaNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BucketOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SegSize != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.SegSize))
		i--
		dAtA[i] = 0x30
	}
	if m.TagFlag != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.TagFlag))
		i--
		dAtA[i] = 0x28
	}
	if m.ParityCount != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ParityCount))
		i--
		dAtA[i] = 0x20
	}
	if m.DataCount != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.DataCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Policy != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BucketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Deletion {
		i--
		if m.Deletion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.NextOpID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.NextOpID))
		i--
		dAtA[i] = 0x38
	}
	if m.NextObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.NextObjectID))
		i--
		dAtA[i] = 0x30
	}
	if m.UsedBytes != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.UsedBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.MTime != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.MTime))
		i--
		dAtA[i] = 0x18
	}
	if m.CTime != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.CTime))
		i--
		dAtA[i] = 0x10
	}
	if m.BucketID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.BucketID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectForm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectForm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectForm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OpRecord) > 0 {
		dAtA2 := make([]byte, len(m.OpRecord)*10)
		var j1 int
		for _, num := range m.OpRecord {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintFs(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Encryption) > 0 {
		i -= len(m.Encryption)
		copy(dAtA[i:], m.Encryption)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Encryption)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x20
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.BucketID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.BucketID))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectDeleteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectDeleteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectDeleteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectPartInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectPartInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectPartInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ETag) > 0 {
		i -= len(m.ETag)
		copy(dAtA[i:], m.ETag)
		i = encodeVarintFs(dAtA, i, uint64(len(m.ETag)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RawLength != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.RawLength))
		i--
		dAtA[i] = 0x28
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.OpID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.OpID))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ProID))
		i--
		dAtA[i] = 0x18
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegExpire) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegExpire) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegExpire) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x10
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PieceLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PieceLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PieceLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProID) > 0 {
		dAtA4 := make([]byte, len(m.ProID)*10)
		var j3 int
		for _, num := range m.ProID {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintFs(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x10
	}
	if m.Size_ != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PieceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PieceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PieceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SectorID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.SectorID))
		i--
		dAtA[i] = 0x20
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SectorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SectorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CommR) > 0 {
		i -= len(m.CommR)
		copy(dAtA[i:], m.CommR)
		i = encodeVarintFs(dAtA, i, uint64(len(m.CommR)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CommD) > 0 {
		i -= len(m.CommD)
		copy(dAtA[i:], m.CommD)
		i = encodeVarintFs(dAtA, i, uint64(len(m.CommD)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SectorPieces) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectorPieces) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SectorPieces) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PieceID) > 0 {
		for iNdEx := len(m.PieceID) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PieceID[iNdEx])
			copy(dAtA[i:], m.PieceID[iNdEx])
			i = encodeVarintFs(dAtA, i, uint64(len(m.PieceID[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Sector != nil {
		{
			size, err := m.Sector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFs(dAtA []byte, offset int, v uint64) int {
	offset -= sovFs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SuperBlockInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovFs(uint64(m.Version))
	}
	if m.ReplicaNum != 0 {
		n += 1 + sovFs(uint64(m.ReplicaNum))
	}
	if m.NextBucketID != 0 {
		n += 1 + sovFs(uint64(m.NextBucketID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BucketOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovFs(uint64(m.Version))
	}
	if m.Policy != 0 {
		n += 1 + sovFs(uint64(m.Policy))
	}
	if m.DataCount != 0 {
		n += 1 + sovFs(uint64(m.DataCount))
	}
	if m.ParityCount != 0 {
		n += 1 + sovFs(uint64(m.ParityCount))
	}
	if m.TagFlag != 0 {
		n += 1 + sovFs(uint64(m.TagFlag))
	}
	if m.SegSize != 0 {
		n += 1 + sovFs(uint64(m.SegSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BucketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketID != 0 {
		n += 1 + sovFs(uint64(m.BucketID))
	}
	if m.CTime != 0 {
		n += 1 + sovFs(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovFs(uint64(m.MTime))
	}
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.UsedBytes != 0 {
		n += 1 + sovFs(uint64(m.UsedBytes))
	}
	if m.NextObjectID != 0 {
		n += 1 + sovFs(uint64(m.NextObjectID))
	}
	if m.NextOpID != 0 {
		n += 1 + sovFs(uint64(m.NextOpID))
	}
	if m.Deletion {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectForm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OpRecord) > 0 {
		l = 0
		for _, e := range m.OpRecord {
			l += sovFs(uint64(e))
		}
		n += 1 + sovFs(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovFs(uint64(m.ObjectID))
	}
	if m.BucketID != 0 {
		n += 1 + sovFs(uint64(m.BucketID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.Encryption)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectDeleteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovFs(uint64(m.ObjectID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectPartInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovFs(uint64(m.ObjectID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	if m.Offset != 0 {
		n += 1 + sovFs(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.RawLength != 0 {
		n += 1 + sovFs(uint64(m.RawLength))
	}
	l = len(m.ETag)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFs(uint64(m.Type))
	}
	if m.OpID != 0 {
		n += 1 + sovFs(uint64(m.OpID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.ProID != 0 {
		n += 1 + sovFs(uint64(m.ProID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegExpire) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PieceLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovFs(uint64(m.Size_))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if len(m.ProID) > 0 {
		l = 0
		for _, e := range m.ProID {
			l += sovFs(uint64(e))
		}
		n += 1 + sovFs(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PieceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovFs(uint64(m.Offset))
	}
	if m.Size_ != 0 {
		n += 1 + sovFs(uint64(m.Size_))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if m.SectorID != 0 {
		n += 1 + sovFs(uint64(m.SectorID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SectorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	l = len(m.CommD)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.CommR)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SectorPieces) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sector != nil {
		l = m.Sector.Size()
		n += 1 + l + sovFs(uint64(l))
	}
	if len(m.PieceID) > 0 {
		for _, b := range m.PieceID {
			l = len(b)
			n += 1 + l + sovFs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFs(x uint64) (n int) {
	return sovFs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SuperBlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuperBlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuperBlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNum", wireType)
			}
			m.ReplicaNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextBucketID", wireType)
			}
			m.NextBucketID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextBucketID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCount", wireType)
			}
			m.DataCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityCount", wireType)
			}
			m.ParityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParityCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagFlag", wireType)
			}
			m.TagFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegSize", wireType)
			}
			m.SegSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketID", wireType)
			}
			m.BucketID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			m.UsedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextObjectID", wireType)
			}
			m.NextObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextOpID", wireType)
			}
			m.NextOpID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextOpID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deletion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deletion = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectForm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectForm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectForm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OpRecord = append(m.OpRecord, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFs
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFs
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OpRecord) == 0 {
					m.OpRecord = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OpRecord = append(m.OpRecord, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OpRecord", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketID", wireType)
			}
			m.BucketID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encryption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectDeleteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectDeleteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectDeleteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectPartInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectPartInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectPartInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawLength", wireType)
			}
			m.RawLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ETag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ETag = append(m.ETag[:0], dAtA[iNdEx:postIndex]...)
			if m.ETag == nil {
				m.ETag = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= OpRecord_OpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpID", wireType)
			}
			m.OpID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProID", wireType)
			}
			m.ProID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegExpire) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegExpire: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegExpire: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PieceLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PieceLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PieceLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ProID = append(m.ProID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFs
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFs
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ProID) == 0 {
					m.ProID = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ProID = append(m.ProID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PieceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PieceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PieceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectorID", wireType)
			}
			m.SectorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommD = append(m.CommD[:0], dAtA[iNdEx:postIndex]...)
			if m.CommD == nil {
				m.CommD = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommR = append(m.CommR[:0], dAtA[iNdEx:postIndex]...)
			if m.CommR == nil {
				m.CommR = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectorPieces) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectorPieces: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectorPieces: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sector == nil {
				m.Sector = &SectorInfo{}
			}
			if err := m.Sector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PieceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PieceID = append(m.PieceID, make([]byte, postIndex-iNdEx))
			copy(m.PieceID[len(m.PieceID)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFs = fmt.Errorf("proto: unexpected end of group")
)
