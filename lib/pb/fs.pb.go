// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fs.proto

package pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// kv key type
type MetaType int32

const (
	MetaType_Unknown      MetaType = 0
	MetaType_LocalNetKey  MetaType = 1
	MetaType_LocalID      MetaType = 2
	MetaType_LocalAddr    MetaType = 3
	MetaType_NetInfoKey   MetaType = 4
	MetaType_PDPProveKey  MetaType = 5
	MetaType_PDPVerifyKey MetaType = 6
	MetaType_FsMemberKey  MetaType = 7
	// lfs meta
	MetaType_LFS_BucketCountKey  MetaType = 10
	MetaType_LFS_BucketOptionKey MetaType = 11
	MetaType_LFS_BucketInfoKey   MetaType = 12
	MetaType_LFS_OpInfoKey       MetaType = 13
	MetaType_LFS_OpDoneKey       MetaType = 14
	MetaType_LFS_OpCountKey      MetaType = 15
	MetaType_LFS_StripeCountKey  MetaType = 16
	MetaType_MessageKey          MetaType = 18
	MetaType_MessageStateKey     MetaType = 19
	// key in state tree
	MetaType_ST_GasMoneyKey   MetaType = 20
	MetaType_ST_NodeInfoKey   MetaType = 21
	MetaType_ST_BucketOptKey  MetaType = 23
	MetaType_ST_SegLocKey     MetaType = 24
	MetaType_ST_SegExpireKey  MetaType = 25
	MetaType_ST_PieceLocKey   MetaType = 26
	MetaType_ST_SectorInfoKey MetaType = 27
	MetaType_ST_DataOrderKey  MetaType = 30
	MetaType_ST_EpochKey      MetaType = 31
	//ST_ChalSeedKey = 32;     // key: x/epoch; val: height, seed, time
	MetaType_ST_IncomeKey     MetaType = 33
	MetaType_ST_ChalSegResKey MetaType = 34
	MetaType_ST_ChalSecResKey MetaType = 35
	// data meta
	MetaType_PieceInfoKey    MetaType = 40
	MetaType_SectorPiecesKey MetaType = 41
	MetaType_SectorCountKey  MetaType = 42
	MetaType_SectorSetKey    MetaType = 43
	MetaType_OrderTxKey      MetaType = 44
	// order
	MetaType_OrderNonceKey MetaType = 50
	MetaType_OrderBaseKey  MetaType = 51
	MetaType_OrderSeqKey   MetaType = 52
)

var MetaType_name = map[int32]string{
	0:  "Unknown",
	1:  "LocalNetKey",
	2:  "LocalID",
	3:  "LocalAddr",
	4:  "NetInfoKey",
	5:  "PDPProveKey",
	6:  "PDPVerifyKey",
	7:  "FsMemberKey",
	10: "LFS_BucketCountKey",
	11: "LFS_BucketOptionKey",
	12: "LFS_BucketInfoKey",
	13: "LFS_OpInfoKey",
	14: "LFS_OpDoneKey",
	15: "LFS_OpCountKey",
	16: "LFS_StripeCountKey",
	18: "MessageKey",
	19: "MessageStateKey",
	20: "ST_GasMoneyKey",
	21: "ST_NodeInfoKey",
	23: "ST_BucketOptKey",
	24: "ST_SegLocKey",
	25: "ST_SegExpireKey",
	26: "ST_PieceLocKey",
	27: "ST_SectorInfoKey",
	30: "ST_DataOrderKey",
	31: "ST_EpochKey",
	33: "ST_IncomeKey",
	34: "ST_ChalSegResKey",
	35: "ST_ChalSecResKey",
	40: "PieceInfoKey",
	41: "SectorPiecesKey",
	42: "SectorCountKey",
	43: "SectorSetKey",
	44: "OrderTxKey",
	50: "OrderNonceKey",
	51: "OrderBaseKey",
	52: "OrderSeqKey",
}

var MetaType_value = map[string]int32{
	"Unknown":             0,
	"LocalNetKey":         1,
	"LocalID":             2,
	"LocalAddr":           3,
	"NetInfoKey":          4,
	"PDPProveKey":         5,
	"PDPVerifyKey":        6,
	"FsMemberKey":         7,
	"LFS_BucketCountKey":  10,
	"LFS_BucketOptionKey": 11,
	"LFS_BucketInfoKey":   12,
	"LFS_OpInfoKey":       13,
	"LFS_OpDoneKey":       14,
	"LFS_OpCountKey":      15,
	"LFS_StripeCountKey":  16,
	"MessageKey":          18,
	"MessageStateKey":     19,
	"ST_GasMoneyKey":      20,
	"ST_NodeInfoKey":      21,
	"ST_BucketOptKey":     23,
	"ST_SegLocKey":        24,
	"ST_SegExpireKey":     25,
	"ST_PieceLocKey":      26,
	"ST_SectorInfoKey":    27,
	"ST_DataOrderKey":     30,
	"ST_EpochKey":         31,
	"ST_IncomeKey":        33,
	"ST_ChalSegResKey":    34,
	"ST_ChalSecResKey":    35,
	"PieceInfoKey":        40,
	"SectorPiecesKey":     41,
	"SectorCountKey":      42,
	"SectorSetKey":        43,
	"OrderTxKey":          44,
	"OrderNonceKey":       50,
	"OrderBaseKey":        51,
	"OrderSeqKey":         52,
}

func (x MetaType) String() string {
	return proto.EnumName(MetaType_name, int32(x))
}

func (MetaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{0}
}

type DataType int32

const (
	DataType_DataErr DataType = 0
	DataType_Segment DataType = 1
	DataType_Piece   DataType = 2
	DataType_Sector  DataType = 3
)

var DataType_name = map[int32]string{
	0: "DataErr",
	1: "Segment",
	2: "Piece",
	3: "Sector",
}

var DataType_value = map[string]int32{
	"DataErr": 0,
	"Segment": 1,
	"Piece":   2,
	"Sector":  3,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{1}
}

type BucketRecord_OpType int32

const (
	BucketRecord_Unknown      BucketRecord_OpType = 0
	BucketRecord_CreateObject BucketRecord_OpType = 1
	BucketRecord_AddData      BucketRecord_OpType = 2
	BucketRecord_DeleteObject BucketRecord_OpType = 3
)

var BucketRecord_OpType_name = map[int32]string{
	0: "Unknown",
	1: "CreateObject",
	2: "AddData",
	3: "DeleteObject",
}

var BucketRecord_OpType_value = map[string]int32{
	"Unknown":      0,
	"CreateObject": 1,
	"AddData":      2,
	"DeleteObject": 3,
}

func (x BucketRecord_OpType) String() string {
	return proto.EnumName(BucketRecord_OpType_name, int32(x))
}

func (BucketRecord_OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{4, 0}
}

//    =============  lfs information  ================
// 'BucketCountKey'/fsID
// 'StripeCountKey'/fsID/bucketID
// key: 'BucketOptionKey'/fsID/bucketID
type BucketOption struct {
	Version              uint32   `protobuf:"varint,1,opt,name=Version,json=version,proto3" json:"Version,omitempty"`
	Policy               uint32   `protobuf:"varint,2,opt,name=Policy,json=policy,proto3" json:"Policy,omitempty"`
	DataCount            uint32   `protobuf:"varint,3,opt,name=DataCount,json=dataCount,proto3" json:"DataCount,omitempty"`
	ParityCount          uint32   `protobuf:"varint,4,opt,name=ParityCount,json=parityCount,proto3" json:"ParityCount,omitempty"`
	TagFlag              uint32   `protobuf:"varint,5,opt,name=TagFlag,json=tagFlag,proto3" json:"TagFlag,omitempty"`
	SegSize              uint32   `protobuf:"varint,6,opt,name=SegSize,json=segSize,proto3" json:"SegSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BucketOption) Reset()         { *m = BucketOption{} }
func (m *BucketOption) String() string { return proto.CompactTextString(m) }
func (*BucketOption) ProtoMessage()    {}
func (*BucketOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{0}
}
func (m *BucketOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketOption.Merge(m, src)
}
func (m *BucketOption) XXX_Size() int {
	return m.Size()
}
func (m *BucketOption) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketOption.DiscardUnknown(m)
}

var xxx_messageInfo_BucketOption proto.InternalMessageInfo

func (m *BucketOption) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BucketOption) GetPolicy() uint32 {
	if m != nil {
		return m.Policy
	}
	return 0
}

func (m *BucketOption) GetDataCount() uint32 {
	if m != nil {
		return m.DataCount
	}
	return 0
}

func (m *BucketOption) GetParityCount() uint32 {
	if m != nil {
		return m.ParityCount
	}
	return 0
}

func (m *BucketOption) GetTagFlag() uint32 {
	if m != nil {
		return m.TagFlag
	}
	return 0
}

func (m *BucketOption) GetSegSize() uint32 {
	if m != nil {
		return m.SegSize
	}
	return 0
}

// key: 'BucketInfoKey'/fsID/bucketID
type BucketInfo struct {
	BucketID             uint64   `protobuf:"varint,1,opt,name=BucketID,json=bucketID,proto3" json:"BucketID,omitempty"`
	CTime                uint64   `protobuf:"varint,2,opt,name=CTime,json=cTime,proto3" json:"CTime,omitempty"`
	MTime                uint64   `protobuf:"varint,3,opt,name=MTime,json=mTime,proto3" json:"MTime,omitempty"`
	Size_                uint64   `protobuf:"varint,4,opt,name=Size,json=size,proto3" json:"Size,omitempty"`
	UsedBytes            uint64   `protobuf:"varint,5,opt,name=UsedBytes,json=usedBytes,proto3" json:"UsedBytes,omitempty"`
	ObjectCount          uint64   `protobuf:"varint,6,opt,name=ObjectCount,json=objectCount,proto3" json:"ObjectCount,omitempty"`
	OpCount              uint64   `protobuf:"varint,7,opt,name=OpCount,json=opCount,proto3" json:"OpCount,omitempty"`
	Deletion             bool     `protobuf:"varint,8,opt,name=deletion,proto3" json:"deletion,omitempty"`
	Name                 string   `protobuf:"bytes,9,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
	Root                 []byte   `protobuf:"bytes,10,opt,name=Root,json=root,proto3" json:"Root,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BucketInfo) Reset()         { *m = BucketInfo{} }
func (m *BucketInfo) String() string { return proto.CompactTextString(m) }
func (*BucketInfo) ProtoMessage()    {}
func (*BucketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{1}
}
func (m *BucketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketInfo.Merge(m, src)
}
func (m *BucketInfo) XXX_Size() int {
	return m.Size()
}
func (m *BucketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BucketInfo proto.InternalMessageInfo

func (m *BucketInfo) GetBucketID() uint64 {
	if m != nil {
		return m.BucketID
	}
	return 0
}

func (m *BucketInfo) GetCTime() uint64 {
	if m != nil {
		return m.CTime
	}
	return 0
}

func (m *BucketInfo) GetMTime() uint64 {
	if m != nil {
		return m.MTime
	}
	return 0
}

func (m *BucketInfo) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *BucketInfo) GetUsedBytes() uint64 {
	if m != nil {
		return m.UsedBytes
	}
	return 0
}

func (m *BucketInfo) GetObjectCount() uint64 {
	if m != nil {
		return m.ObjectCount
	}
	return 0
}

func (m *BucketInfo) GetOpCount() uint64 {
	if m != nil {
		return m.OpCount
	}
	return 0
}

func (m *BucketInfo) GetDeletion() bool {
	if m != nil {
		return m.Deletion
	}
	return false
}

func (m *BucketInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BucketInfo) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

// object information; when create object
type ObjectInfo struct {
	ObjectID             uint64   `protobuf:"varint,1,opt,name=ObjectID,json=objectID,proto3" json:"ObjectID,omitempty"`
	BucketID             uint64   `protobuf:"varint,2,opt,name=BucketID,json=bucketID,proto3" json:"BucketID,omitempty"`
	Time                 uint64   `protobuf:"varint,3,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Expire               uint64   `protobuf:"varint,4,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	Name                 string   `protobuf:"bytes,5,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
	Encryption           string   `protobuf:"bytes,6,opt,name=Encryption,json=encryption,proto3" json:"Encryption,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectInfo) Reset()         { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()    {}
func (*ObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{2}
}
func (m *ObjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectInfo.Merge(m, src)
}
func (m *ObjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectInfo proto.InternalMessageInfo

func (m *ObjectInfo) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *ObjectInfo) GetBucketID() uint64 {
	if m != nil {
		return m.BucketID
	}
	return 0
}

func (m *ObjectInfo) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ObjectInfo) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *ObjectInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectInfo) GetEncryption() string {
	if m != nil {
		return m.Encryption
	}
	return ""
}

// opart informations, insert into object when add data to an existing object
type PartInfo struct {
	ObjectID             uint64   `protobuf:"varint,1,opt,name=ObjectID,json=objectID,proto3" json:"ObjectID,omitempty"`
	OpID                 uint64   `protobuf:"varint,2,opt,name=OpID,json=opID,proto3" json:"OpID,omitempty"`
	Time                 uint64   `protobuf:"varint,3,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Offset               uint64   `protobuf:"varint,4,opt,name=Offset,json=offset,proto3" json:"Offset,omitempty"`
	Size_                uint64   `protobuf:"varint,5,opt,name=Size,json=size,proto3" json:"Size,omitempty"`
	UsedBytes            uint64   `protobuf:"varint,6,opt,name=UsedBytes,json=usedBytes,proto3" json:"UsedBytes,omitempty"`
	ETag                 []byte   `protobuf:"bytes,7,opt,name=ETag,json=eTag,proto3" json:"ETag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartInfo) Reset()         { *m = PartInfo{} }
func (m *PartInfo) String() string { return proto.CompactTextString(m) }
func (*PartInfo) ProtoMessage()    {}
func (*PartInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{3}
}
func (m *PartInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartInfo.Merge(m, src)
}
func (m *PartInfo) XXX_Size() int {
	return m.Size()
}
func (m *PartInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PartInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PartInfo proto.InternalMessageInfo

func (m *PartInfo) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *PartInfo) GetOpID() uint64 {
	if m != nil {
		return m.OpID
	}
	return 0
}

func (m *PartInfo) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *PartInfo) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PartInfo) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *PartInfo) GetUsedBytes() uint64 {
	if m != nil {
		return m.UsedBytes
	}
	return 0
}

func (m *PartInfo) GetETag() []byte {
	if m != nil {
		return m.ETag
	}
	return nil
}

// 'OpDoneKey'/fsID/bucketID
// 'OpCountKey'/fsID/bucketID
// key: 'OpInfoKey'/fsID/bucketID/opID
type BucketRecord struct {
	Type                 BucketRecord_OpType `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=pb.BucketRecord_OpType" json:"Type,omitempty"`
	OpID                 uint64              `protobuf:"varint,2,opt,name=OpID,json=opID,proto3" json:"OpID,omitempty"`
	Time                 uint64              `protobuf:"varint,3,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Payload              []byte              `protobuf:"bytes,4,opt,name=Payload,json=payload,proto3" json:"Payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BucketRecord) Reset()         { *m = BucketRecord{} }
func (m *BucketRecord) String() string { return proto.CompactTextString(m) }
func (*BucketRecord) ProtoMessage()    {}
func (*BucketRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{4}
}
func (m *BucketRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketRecord.Merge(m, src)
}
func (m *BucketRecord) XXX_Size() int {
	return m.Size()
}
func (m *BucketRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketRecord.DiscardUnknown(m)
}

var xxx_messageInfo_BucketRecord proto.InternalMessageInfo

func (m *BucketRecord) GetType() BucketRecord_OpType {
	if m != nil {
		return m.Type
	}
	return BucketRecord_Unknown
}

func (m *BucketRecord) GetOpID() uint64 {
	if m != nil {
		return m.OpID
	}
	return 0
}

func (m *BucketRecord) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *BucketRecord) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// key: 'SegLocKey'/fsID_bucketID_chunkID_stripeID
type SegLocation struct {
	Expire               uint64   `protobuf:"varint,1,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	Length               uint64   `protobuf:"varint,2,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	ProID                uint64   `protobuf:"varint,3,opt,name=ProID,json=proID,proto3" json:"ProID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SegLocation) Reset()         { *m = SegLocation{} }
func (m *SegLocation) String() string { return proto.CompactTextString(m) }
func (*SegLocation) ProtoMessage()    {}
func (*SegLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{5}
}
func (m *SegLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegLocation.Merge(m, src)
}
func (m *SegLocation) XXX_Size() int {
	return m.Size()
}
func (m *SegLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_SegLocation.DiscardUnknown(m)
}

var xxx_messageInfo_SegLocation proto.InternalMessageInfo

func (m *SegLocation) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *SegLocation) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SegLocation) GetProID() uint64 {
	if m != nil {
		return m.ProID
	}
	return 0
}

// key: 'SegExpireKey'/fsID_bucketID_stripeID
type SegExpire struct {
	Length               uint64   `protobuf:"varint,1,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	Expire               uint64   `protobuf:"varint,2,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SegExpire) Reset()         { *m = SegExpire{} }
func (m *SegExpire) String() string { return proto.CompactTextString(m) }
func (*SegExpire) ProtoMessage()    {}
func (*SegExpire) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{6}
}
func (m *SegExpire) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegExpire) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegExpire.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegExpire) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegExpire.Merge(m, src)
}
func (m *SegExpire) XXX_Size() int {
	return m.Size()
}
func (m *SegExpire) XXX_DiscardUnknown() {
	xxx_messageInfo_SegExpire.DiscardUnknown(m)
}

var xxx_messageInfo_SegExpire proto.InternalMessageInfo

func (m *SegExpire) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SegExpire) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

// key: 'PieceLocKey'/pieceID; on keeper and user
type PieceLocation struct {
	Size_                uint32   `protobuf:"varint,1,opt,name=Size,json=size,proto3" json:"Size,omitempty"`
	Expire               uint64   `protobuf:"varint,2,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	ProID                []uint64 `protobuf:"varint,3,rep,packed,name=ProID,json=proID,proto3" json:"ProID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PieceLocation) Reset()         { *m = PieceLocation{} }
func (m *PieceLocation) String() string { return proto.CompactTextString(m) }
func (*PieceLocation) ProtoMessage()    {}
func (*PieceLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{7}
}
func (m *PieceLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PieceLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PieceLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PieceLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceLocation.Merge(m, src)
}
func (m *PieceLocation) XXX_Size() int {
	return m.Size()
}
func (m *PieceLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceLocation.DiscardUnknown(m)
}

var xxx_messageInfo_PieceLocation proto.InternalMessageInfo

func (m *PieceLocation) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *PieceLocation) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *PieceLocation) GetProID() []uint64 {
	if m != nil {
		return m.ProID
	}
	return nil
}

// fsID need?
// key: 'PieceInfoKey'/pieceID; on provider
type PieceInfo struct {
	Offset               uint32   `protobuf:"varint,1,opt,name=Offset,json=offset,proto3" json:"Offset,omitempty"`
	Size_                uint32   `protobuf:"varint,2,opt,name=Size,json=size,proto3" json:"Size,omitempty"`
	Expire               uint64   `protobuf:"varint,3,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	SectorID             uint64   `protobuf:"varint,4,opt,name=SectorID,json=sectorID,proto3" json:"SectorID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PieceInfo) Reset()         { *m = PieceInfo{} }
func (m *PieceInfo) String() string { return proto.CompactTextString(m) }
func (*PieceInfo) ProtoMessage()    {}
func (*PieceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{8}
}
func (m *PieceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PieceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PieceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PieceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PieceInfo.Merge(m, src)
}
func (m *PieceInfo) XXX_Size() int {
	return m.Size()
}
func (m *PieceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PieceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PieceInfo proto.InternalMessageInfo

func (m *PieceInfo) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PieceInfo) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *PieceInfo) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *PieceInfo) GetSectorID() uint64 {
	if m != nil {
		return m.SectorID
	}
	return 0
}

// 'SectorCountKey'/proID; on keeper and provider
// 'SectorSetKey'/proID; on keeper and provider
// key: 'SectorInfoKey'/pieceID; on keeper, 70 bytes
type SectorInfo struct {
	Expire               uint64   `protobuf:"varint,1,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	CommD                []byte   `protobuf:"bytes,2,opt,name=CommD,json=commD,proto3" json:"CommD,omitempty"`
	CommR                []byte   `protobuf:"bytes,3,opt,name=CommR,json=commR,proto3" json:"CommR,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SectorInfo) Reset()         { *m = SectorInfo{} }
func (m *SectorInfo) String() string { return proto.CompactTextString(m) }
func (*SectorInfo) ProtoMessage()    {}
func (*SectorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{9}
}
func (m *SectorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SectorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SectorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SectorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SectorInfo.Merge(m, src)
}
func (m *SectorInfo) XXX_Size() int {
	return m.Size()
}
func (m *SectorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SectorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SectorInfo proto.InternalMessageInfo

func (m *SectorInfo) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *SectorInfo) GetCommD() []byte {
	if m != nil {
		return m.CommD
	}
	return nil
}

func (m *SectorInfo) GetCommR() []byte {
	if m != nil {
		return m.CommR
	}
	return nil
}

// key: 'SectorPiecesKey'/sectorID; on provider
type SectorPieces struct {
	Sector               *SectorInfo `protobuf:"bytes,1,opt,name=Sector,json=sector,proto3" json:"Sector,omitempty"`
	PieceID              [][]byte    `protobuf:"bytes,2,rep,name=PieceID,json=pieceID,proto3" json:"PieceID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SectorPieces) Reset()         { *m = SectorPieces{} }
func (m *SectorPieces) String() string { return proto.CompactTextString(m) }
func (*SectorPieces) ProtoMessage()    {}
func (*SectorPieces) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{10}
}
func (m *SectorPieces) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SectorPieces) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SectorPieces.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SectorPieces) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SectorPieces.Merge(m, src)
}
func (m *SectorPieces) XXX_Size() int {
	return m.Size()
}
func (m *SectorPieces) XXX_DiscardUnknown() {
	xxx_messageInfo_SectorPieces.DiscardUnknown(m)
}

var xxx_messageInfo_SectorPieces proto.InternalMessageInfo

func (m *SectorPieces) GetSector() *SectorInfo {
	if m != nil {
		return m.Sector
	}
	return nil
}

func (m *SectorPieces) GetPieceID() [][]byte {
	if m != nil {
		return m.PieceID
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.MetaType", MetaType_name, MetaType_value)
	proto.RegisterEnum("pb.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("pb.BucketRecord_OpType", BucketRecord_OpType_name, BucketRecord_OpType_value)
	proto.RegisterType((*BucketOption)(nil), "pb.BucketOption")
	proto.RegisterType((*BucketInfo)(nil), "pb.BucketInfo")
	proto.RegisterType((*ObjectInfo)(nil), "pb.ObjectInfo")
	proto.RegisterType((*PartInfo)(nil), "pb.PartInfo")
	proto.RegisterType((*BucketRecord)(nil), "pb.BucketRecord")
	proto.RegisterType((*SegLocation)(nil), "pb.SegLocation")
	proto.RegisterType((*SegExpire)(nil), "pb.SegExpire")
	proto.RegisterType((*PieceLocation)(nil), "pb.PieceLocation")
	proto.RegisterType((*PieceInfo)(nil), "pb.PieceInfo")
	proto.RegisterType((*SectorInfo)(nil), "pb.SectorInfo")
	proto.RegisterType((*SectorPieces)(nil), "pb.SectorPieces")
}

func init() { proto.RegisterFile("fs.proto", fileDescriptor_e604833c2b457e38) }

var fileDescriptor_e604833c2b457e38 = []byte{
	// 1084 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x96, 0xc1, 0x52, 0xe3, 0x46,
	0x10, 0x86, 0x91, 0x2d, 0xcb, 0x76, 0xdb, 0x80, 0x76, 0x60, 0xc1, 0x21, 0x29, 0x87, 0x28, 0x55,
	0x29, 0xc2, 0xa6, 0x38, 0xb0, 0xb9, 0xed, 0x69, 0xc1, 0x26, 0x45, 0x05, 0xb0, 0x22, 0x79, 0xf7,
	0x4a, 0xc9, 0x72, 0x63, 0x14, 0x6c, 0x8d, 0x22, 0x0d, 0x9b, 0xf5, 0x3e, 0x40, 0x9e, 0x21, 0x0f,
	0x90, 0x63, 0x8e, 0x79, 0x85, 0x54, 0xe5, 0x90, 0x43, 0x1e, 0x21, 0x45, 0x5e, 0x24, 0xd5, 0x3d,
	0x92, 0x6c, 0xc8, 0x52, 0xd9, 0xdb, 0xfe, 0x5f, 0x7b, 0xa6, 0xff, 0xee, 0xe9, 0xd6, 0x02, 0x8d,
	0xab, 0xec, 0x20, 0x49, 0xa5, 0x92, 0xa2, 0x92, 0x8c, 0x9c, 0xdf, 0x0c, 0x68, 0x1f, 0xdd, 0x86,
	0x37, 0xa8, 0x06, 0x89, 0x8a, 0x64, 0x2c, 0x3a, 0x50, 0x7f, 0x8d, 0x69, 0x16, 0xc9, 0xb8, 0x63,
	0xec, 0x1a, 0x7b, 0xab, 0x5e, 0xfd, 0x8d, 0x96, 0x62, 0x0b, 0x2c, 0x57, 0x4e, 0xa3, 0x70, 0xde,
	0xa9, 0x70, 0xc0, 0x4a, 0x58, 0x89, 0x4f, 0xa0, 0xd9, 0x0b, 0x54, 0x70, 0x2c, 0x6f, 0x63, 0xd5,
	0xa9, 0x72, 0xa8, 0x39, 0x2e, 0x80, 0xd8, 0x85, 0x96, 0x1b, 0xa4, 0x91, 0x9a, 0xeb, 0xb8, 0xc9,
	0xf1, 0x56, 0xb2, 0x40, 0x94, 0x71, 0x18, 0x4c, 0x4e, 0xa6, 0xc1, 0xa4, 0x53, 0xd3, 0x19, 0x95,
	0x96, 0x14, 0xf1, 0x71, 0xe2, 0x47, 0xef, 0xb0, 0x63, 0xe9, 0x48, 0xa6, 0xa5, 0xf3, 0x53, 0x05,
	0x40, 0xdb, 0x3e, 0x8d, 0xaf, 0xa4, 0xd8, 0x81, 0x46, 0xae, 0x7a, 0xec, 0xda, 0xf4, 0x1a, 0xa3,
	0x5c, 0x8b, 0x4d, 0xa8, 0x1d, 0x0f, 0xa3, 0x19, 0xb2, 0x6b, 0xd3, 0xab, 0x85, 0x24, 0x88, 0x9e,
	0x33, 0xad, 0x6a, 0x3a, 0x63, 0x2a, 0xc0, 0xe4, 0x6c, 0x26, 0x43, 0x33, 0x8b, 0xde, 0x21, 0x95,
	0xf7, 0x2a, 0xc3, 0xf1, 0xd1, 0x5c, 0x61, 0xc6, 0x06, 0x4d, 0xaf, 0x79, 0x5b, 0x00, 0x2a, 0x6f,
	0x30, 0xfa, 0x1e, 0x43, 0xa5, 0xcb, 0xb3, 0x38, 0xde, 0x92, 0x0b, 0x44, 0x45, 0x0c, 0x12, 0x1d,
	0xad, 0x73, 0xb4, 0x2e, 0xb5, 0x24, 0xd7, 0x63, 0x9c, 0x22, 0xb5, 0xbd, 0xd3, 0xd8, 0x35, 0xf6,
	0x1a, 0x5e, 0xa9, 0xc9, 0xc9, 0x45, 0x30, 0xc3, 0x4e, 0x73, 0xd7, 0xd8, 0x6b, 0x7a, 0x66, 0x1c,
	0x68, 0x77, 0x9e, 0x94, 0xaa, 0x03, 0xbb, 0xc6, 0x5e, 0xdb, 0x33, 0x53, 0x29, 0x95, 0xf3, 0x8b,
	0x01, 0xa0, 0x0d, 0x14, 0x8d, 0xc8, 0x55, 0xd9, 0x08, 0x99, 0xeb, 0x7b, 0x4d, 0xaa, 0x3c, 0x68,
	0x92, 0x00, 0x73, 0xa9, 0x1b, 0xa6, 0xa2, 0x66, 0x6c, 0x81, 0xd5, 0x7f, 0x9b, 0x44, 0x69, 0xd1,
	0x0e, 0x0b, 0x59, 0x95, 0xd6, 0x6a, 0x4b, 0xd6, 0xba, 0x00, 0xfd, 0x38, 0x4c, 0xe7, 0x3c, 0x43,
	0xdc, 0x85, 0xa6, 0x07, 0x58, 0x12, 0xe7, 0x57, 0x03, 0x1a, 0x6e, 0x90, 0xfe, 0xbf, 0x49, 0x01,
	0xe6, 0x20, 0x29, 0x0d, 0x9a, 0x32, 0x79, 0xdc, 0xdc, 0xe0, 0xea, 0x2a, 0x43, 0x55, 0x98, 0x93,
	0xac, 0xca, 0x17, 0xac, 0x3d, 0xf6, 0x82, 0xd6, 0xc3, 0x17, 0x14, 0x60, 0xf6, 0x87, 0xc1, 0x84,
	0x1f, 0xa7, 0xed, 0x99, 0x38, 0x0c, 0x26, 0xce, 0xef, 0xe5, 0x56, 0x78, 0x18, 0xca, 0x74, 0x2c,
	0x9e, 0x81, 0x39, 0x9c, 0x27, 0xc8, 0x76, 0xd7, 0x0e, 0xb7, 0x0f, 0x92, 0xd1, 0xc1, 0x72, 0xfc,
	0x60, 0x90, 0x50, 0xd8, 0x33, 0xd5, 0x3c, 0xc1, 0x0f, 0xae, 0xa1, 0x03, 0x75, 0x37, 0x98, 0x4f,
	0x65, 0x30, 0xe6, 0x22, 0xda, 0x5e, 0x3d, 0xd1, 0xd2, 0x39, 0x01, 0x4b, 0xdf, 0x28, 0x5a, 0x50,
	0x7f, 0x15, 0xdf, 0xc4, 0xf2, 0xc7, 0xd8, 0x5e, 0x11, 0x36, 0xb4, 0x8f, 0x53, 0x0c, 0x14, 0xea,
	0xf6, 0xd9, 0x06, 0x85, 0x5f, 0x8e, 0xc7, 0xb4, 0x7e, 0x76, 0x85, 0xc2, 0x3d, 0x9a, 0x9f, 0x22,
	0x5c, 0x75, 0x7c, 0x68, 0xf9, 0x38, 0x39, 0x93, 0x61, 0xa0, 0xf2, 0x0d, 0xce, 0x5f, 0xd4, 0xb8,
	0xf7, 0xa2, 0x5b, 0x60, 0x9d, 0x61, 0x3c, 0x51, 0xd7, 0xb9, 0x65, 0x6b, 0xca, 0x8a, 0x96, 0xc4,
	0x4d, 0xe5, 0x69, 0xaf, 0x58, 0x92, 0x84, 0x84, 0xf3, 0x02, 0x9a, 0x3e, 0x4e, 0xfa, 0x0f, 0x8f,
	0x1a, 0xf7, 0x8e, 0x2e, 0x52, 0x55, 0x96, 0x53, 0x39, 0xdf, 0xc1, 0xaa, 0x1b, 0x61, 0x88, 0xa5,
	0xa7, 0xe2, 0xc1, 0xf4, 0xc7, 0x46, 0x3f, 0xd8, 0x23, 0x87, 0x97, 0xfd, 0x54, 0x17, 0x7e, 0x6e,
	0xa0, 0xc9, 0x57, 0xf2, 0x6c, 0x2d, 0xe6, 0x42, 0x5f, 0xf8, 0x70, 0x2e, 0x2a, 0xef, 0x4d, 0x53,
	0xbd, 0x97, 0x66, 0x07, 0x1a, 0x3e, 0x86, 0x4a, 0xa6, 0xa7, 0xbd, 0x7c, 0xba, 0x1a, 0x59, 0xae,
	0x1d, 0x17, 0x20, 0x8f, 0xe5, 0xd9, 0xde, 0xdb, 0x50, 0xfa, 0xe6, 0xc8, 0xd9, 0x4c, 0x8f, 0x40,
	0xdb, 0xab, 0x85, 0x24, 0x0a, 0xea, 0x71, 0xba, 0x9c, 0x7a, 0x8e, 0x0b, 0x6d, 0x7d, 0x23, 0x17,
	0x91, 0x89, 0x2f, 0xc0, 0xd2, 0x9a, 0xef, 0x6c, 0x1d, 0xae, 0xd1, 0xb0, 0x2d, 0x72, 0x7a, 0x96,
	0xf6, 0xc2, 0xd3, 0xc3, 0x65, 0x53, 0x96, 0x2a, 0x4f, 0x8f, 0x96, 0xfb, 0x7f, 0xd6, 0xa0, 0x71,
	0x8e, 0x2a, 0xf8, 0xef, 0x00, 0xad, 0x43, 0x8b, 0x1a, 0x3f, 0xbd, 0x40, 0xf5, 0x2d, 0xce, 0xf5,
	0xfc, 0x30, 0x38, 0xed, 0xd9, 0x15, 0xb1, 0x0a, 0x4d, 0x16, 0x2f, 0xc7, 0xe3, 0xd4, 0xae, 0x8a,
	0x35, 0x80, 0x0b, 0xfd, 0x7d, 0xa5, 0xdf, 0x9a, 0x74, 0xd8, 0xed, 0xb9, 0x6e, 0x2a, 0xdf, 0x20,
	0x81, 0x1a, 0xcd, 0x9b, 0xdb, 0x73, 0x5f, 0x63, 0x1a, 0x5d, 0xcd, 0x89, 0x58, 0xf4, 0x93, 0x93,
	0xec, 0x1c, 0x67, 0x23, 0x4c, 0x09, 0xd4, 0xc5, 0x16, 0x88, 0xb3, 0x13, 0xff, 0x52, 0xef, 0x0a,
	0x7f, 0xf5, 0x88, 0x83, 0xd8, 0x86, 0x8d, 0x05, 0xd7, 0xff, 0xf3, 0x50, 0xa0, 0x25, 0x9e, 0xc2,
	0x93, 0x45, 0xa0, 0xc8, 0xdd, 0x16, 0x4f, 0x60, 0x95, 0xf0, 0x20, 0x29, 0xd0, 0xea, 0x02, 0xf5,
	0x64, 0xcc, 0x86, 0xd6, 0x84, 0x80, 0x35, 0x8d, 0xca, 0x4c, 0xeb, 0x85, 0x03, 0x5f, 0xa5, 0x51,
	0x82, 0x25, 0xb7, 0xa9, 0xba, 0x73, 0xcc, 0xb2, 0x60, 0xc2, 0x67, 0x85, 0xd8, 0x80, 0xf5, 0x5c,
	0xfb, 0x2a, 0x50, 0x0c, 0x37, 0xe8, 0x42, 0x7f, 0x78, 0xf9, 0x4d, 0x90, 0x9d, 0xcb, 0x18, 0xb9,
	0xc6, 0xcd, 0x9c, 0x5d, 0xc8, 0x31, 0x16, 0x5e, 0x9e, 0xd2, 0x61, 0x7f, 0xb8, 0xa8, 0x86, 0xe0,
	0x36, 0xb5, 0xc7, 0x1f, 0x5e, 0xea, 0xfd, 0x23, 0xd2, 0xc9, 0x7f, 0x56, 0x2e, 0x0f, 0xc1, 0x8f,
	0xf2, 0xfb, 0x8a, 0xa5, 0x20, 0xb6, 0x23, 0x36, 0xc1, 0xe6, 0x1f, 0x16, 0x8f, 0x4e, 0xf4, 0xe3,
	0xfc, 0x38, 0x2d, 0xfb, 0x20, 0x1d, 0xeb, 0x0e, 0x77, 0xa9, 0xe5, 0xfe, 0xf0, 0xb2, 0x9f, 0xc8,
	0xf0, 0x9a, 0xc0, 0xa7, 0x79, 0xda, 0xd3, 0x38, 0x94, 0x33, 0xce, 0xf0, 0x59, 0x7e, 0xdb, 0xf1,
	0x75, 0x30, 0xf5, 0x71, 0xe2, 0x61, 0x46, 0xd4, 0xb9, 0x47, 0xc3, 0x9c, 0x7e, 0xce, 0x6f, 0x5a,
	0x2c, 0x13, 0x91, 0x3d, 0xce, 0xba, 0x34, 0x9f, 0x04, 0xbf, 0x64, 0xd3, 0x0c, 0xcb, 0x8e, 0xee,
	0x73, 0x62, 0x66, 0xbe, 0x9e, 0xae, 0x67, 0xd4, 0x63, 0x76, 0x3a, 0x7c, 0x4b, 0xfa, 0x2b, 0x7a,
	0x32, 0xd6, 0x17, 0x32, 0x0e, 0xd9, 0xdb, 0x21, 0x1d, 0x62, 0x74, 0x14, 0x64, 0x4c, 0x9e, 0x53,
	0x41, 0x4c, 0x7c, 0xfc, 0x81, 0xc0, 0xd7, 0xfb, 0x2f, 0xa0, 0x41, 0x35, 0x17, 0xd3, 0x4c, 0xff,
	0xee, 0xa7, 0xa9, 0xbd, 0x42, 0xc2, 0xc7, 0xc9, 0x0c, 0x63, 0xfa, 0x12, 0x36, 0xa1, 0xc6, 0x06,
	0xed, 0x8a, 0x80, 0x62, 0x83, 0xec, 0xea, 0x91, 0xfd, 0xc7, 0x5d, 0xd7, 0xf8, 0xeb, 0xae, 0x6b,
	0xfc, 0x7d, 0xd7, 0x35, 0x7e, 0xfe, 0xa7, 0xbb, 0x32, 0xb2, 0xf8, 0x8f, 0x9f, 0xe7, 0xff, 0x06,
	0x00, 0x00, 0xff, 0xff, 0x74, 0x75, 0x06, 0xb4, 0x08, 0x09, 0x00, 0x00,
}

func (m *BucketOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SegSize != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.SegSize))
		i--
		dAtA[i] = 0x30
	}
	if m.TagFlag != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.TagFlag))
		i--
		dAtA[i] = 0x28
	}
	if m.ParityCount != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ParityCount))
		i--
		dAtA[i] = 0x20
	}
	if m.DataCount != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.DataCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Policy != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BucketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Deletion {
		i--
		if m.Deletion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.OpCount != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.OpCount))
		i--
		dAtA[i] = 0x38
	}
	if m.ObjectCount != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectCount))
		i--
		dAtA[i] = 0x30
	}
	if m.UsedBytes != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.UsedBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.Size_ != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if m.MTime != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.MTime))
		i--
		dAtA[i] = 0x18
	}
	if m.CTime != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.CTime))
		i--
		dAtA[i] = 0x10
	}
	if m.BucketID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.BucketID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Encryption) > 0 {
		i -= len(m.Encryption)
		copy(dAtA[i:], m.Encryption)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Encryption)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x20
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.BucketID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.BucketID))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ETag) > 0 {
		i -= len(m.ETag)
		copy(dAtA[i:], m.ETag)
		i = encodeVarintFs(dAtA, i, uint64(len(m.ETag)))
		i--
		dAtA[i] = 0x3a
	}
	if m.UsedBytes != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.UsedBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.Size_ != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.OpID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.OpID))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BucketRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.OpID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.OpID))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ProID))
		i--
		dAtA[i] = 0x18
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegExpire) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegExpire) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegExpire) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x10
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PieceLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PieceLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PieceLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProID) > 0 {
		dAtA2 := make([]byte, len(m.ProID)*10)
		var j1 int
		for _, num := range m.ProID {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintFs(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x10
	}
	if m.Size_ != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PieceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PieceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PieceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SectorID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.SectorID))
		i--
		dAtA[i] = 0x20
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SectorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SectorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CommR) > 0 {
		i -= len(m.CommR)
		copy(dAtA[i:], m.CommR)
		i = encodeVarintFs(dAtA, i, uint64(len(m.CommR)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CommD) > 0 {
		i -= len(m.CommD)
		copy(dAtA[i:], m.CommD)
		i = encodeVarintFs(dAtA, i, uint64(len(m.CommD)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SectorPieces) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectorPieces) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SectorPieces) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PieceID) > 0 {
		for iNdEx := len(m.PieceID) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PieceID[iNdEx])
			copy(dAtA[i:], m.PieceID[iNdEx])
			i = encodeVarintFs(dAtA, i, uint64(len(m.PieceID[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Sector != nil {
		{
			size, err := m.Sector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFs(dAtA []byte, offset int, v uint64) int {
	offset -= sovFs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BucketOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovFs(uint64(m.Version))
	}
	if m.Policy != 0 {
		n += 1 + sovFs(uint64(m.Policy))
	}
	if m.DataCount != 0 {
		n += 1 + sovFs(uint64(m.DataCount))
	}
	if m.ParityCount != 0 {
		n += 1 + sovFs(uint64(m.ParityCount))
	}
	if m.TagFlag != 0 {
		n += 1 + sovFs(uint64(m.TagFlag))
	}
	if m.SegSize != 0 {
		n += 1 + sovFs(uint64(m.SegSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BucketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketID != 0 {
		n += 1 + sovFs(uint64(m.BucketID))
	}
	if m.CTime != 0 {
		n += 1 + sovFs(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovFs(uint64(m.MTime))
	}
	if m.Size_ != 0 {
		n += 1 + sovFs(uint64(m.Size_))
	}
	if m.UsedBytes != 0 {
		n += 1 + sovFs(uint64(m.UsedBytes))
	}
	if m.ObjectCount != 0 {
		n += 1 + sovFs(uint64(m.ObjectCount))
	}
	if m.OpCount != 0 {
		n += 1 + sovFs(uint64(m.OpCount))
	}
	if m.Deletion {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovFs(uint64(m.ObjectID))
	}
	if m.BucketID != 0 {
		n += 1 + sovFs(uint64(m.BucketID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.Encryption)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovFs(uint64(m.ObjectID))
	}
	if m.OpID != 0 {
		n += 1 + sovFs(uint64(m.OpID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	if m.Offset != 0 {
		n += 1 + sovFs(uint64(m.Offset))
	}
	if m.Size_ != 0 {
		n += 1 + sovFs(uint64(m.Size_))
	}
	if m.UsedBytes != 0 {
		n += 1 + sovFs(uint64(m.UsedBytes))
	}
	l = len(m.ETag)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BucketRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFs(uint64(m.Type))
	}
	if m.OpID != 0 {
		n += 1 + sovFs(uint64(m.OpID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.ProID != 0 {
		n += 1 + sovFs(uint64(m.ProID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegExpire) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PieceLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovFs(uint64(m.Size_))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if len(m.ProID) > 0 {
		l = 0
		for _, e := range m.ProID {
			l += sovFs(uint64(e))
		}
		n += 1 + sovFs(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PieceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovFs(uint64(m.Offset))
	}
	if m.Size_ != 0 {
		n += 1 + sovFs(uint64(m.Size_))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if m.SectorID != 0 {
		n += 1 + sovFs(uint64(m.SectorID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SectorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	l = len(m.CommD)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.CommR)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SectorPieces) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sector != nil {
		l = m.Sector.Size()
		n += 1 + l + sovFs(uint64(l))
	}
	if len(m.PieceID) > 0 {
		for _, b := range m.PieceID {
			l = len(b)
			n += 1 + l + sovFs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFs(x uint64) (n int) {
	return sovFs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BucketOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCount", wireType)
			}
			m.DataCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityCount", wireType)
			}
			m.ParityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParityCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagFlag", wireType)
			}
			m.TagFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegSize", wireType)
			}
			m.SegSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketID", wireType)
			}
			m.BucketID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			m.UsedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectCount", wireType)
			}
			m.ObjectCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCount", wireType)
			}
			m.OpCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deletion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deletion = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketID", wireType)
			}
			m.BucketID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encryption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpID", wireType)
			}
			m.OpID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			m.UsedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ETag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ETag = append(m.ETag[:0], dAtA[iNdEx:postIndex]...)
			if m.ETag == nil {
				m.ETag = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BucketRecord_OpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpID", wireType)
			}
			m.OpID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProID", wireType)
			}
			m.ProID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegExpire) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegExpire: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegExpire: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PieceLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PieceLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PieceLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ProID = append(m.ProID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFs
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFs
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ProID) == 0 {
					m.ProID = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ProID = append(m.ProID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PieceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PieceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PieceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectorID", wireType)
			}
			m.SectorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommD = append(m.CommD[:0], dAtA[iNdEx:postIndex]...)
			if m.CommD == nil {
				m.CommD = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommR = append(m.CommR[:0], dAtA[iNdEx:postIndex]...)
			if m.CommR == nil {
				m.CommR = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectorPieces) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectorPieces: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectorPieces: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sector == nil {
				m.Sector = &SectorInfo{}
			}
			if err := m.Sector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PieceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PieceID = append(m.PieceID, make([]byte, postIndex-iNdEx))
			copy(m.PieceID[len(m.PieceID)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFs = fmt.Errorf("proto: unexpected end of group")
)
