// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fs.proto

package pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// kv key type
type MetaType int32

const (
	MetaType_Unknown     MetaType = 0
	MetaType_RoleInfoKey MetaType = 1
	MetaType_NetInfoKey  MetaType = 2
	// lfs meta
	MetaType_LFS_SuperBlockInfoKey MetaType = 10
	MetaType_LFS_BucketInfoKey     MetaType = 11
	MetaType_LFS_ObjectInfoKey     MetaType = 12
	MetaType_LFS_BucketOptionKey   MetaType = 13
	MetaType_LFS_OpInfoKey         MetaType = 14
	MetaType_LFS_OpJobsKey         MetaType = 15
	MetaType_LFS_OpStateKey        MetaType = 16
	MetaType_LFS_OpCountKey        MetaType = 17
	// key in state
	MetaType_ST_PDPPublicKey   MetaType = 20
	MetaType_ST_BucketOptKey   MetaType = 21
	MetaType_ST_OrderBaseKey   MetaType = 22
	MetaType_ST_OrderSeqKey    MetaType = 23
	MetaType_ST_SegLocKey      MetaType = 24
	MetaType_St_SegMapKey      MetaType = 25
	MetaType_ST_RootKey        MetaType = 30
	MetaType_ST_BlockHeightKey MetaType = 31
	MetaType_ST_EpochKey       MetaType = 32
	// data meta
	MetaType_SegLocationKey     MetaType = 40
	MetaType_Chal_UsersKey      MetaType = 41
	MetaType_Chal_ProofKey      MetaType = 42
	MetaType_Chal_BucketInfoKey MetaType = 43
	// order
	MetaType_OrderNonceKey  MetaType = 50
	MetaType_OrderBaseKey   MetaType = 51
	MetaType_OrderSeqNumKey MetaType = 52
	MetaType_OrderSeqKey    MetaType = 53
	MetaType_OrderProsKey   MetaType = 54
	MetaType_OrderUsersKey  MetaType = 55
	// tx message and block
	MetaType_Tx_BlockSyncedKey  MetaType = 60
	MetaType_TX_BlockKey        MetaType = 61
	MetaType_Tx_BlockHeightKey  MetaType = 62
	MetaType_Tx_NonceKey        MetaType = 63
	MetaType_TX_MessageKey      MetaType = 64
	MetaType_Tx_MessageStateKey MetaType = 65
)

var MetaType_name = map[int32]string{
	0:  "Unknown",
	1:  "RoleInfoKey",
	2:  "NetInfoKey",
	10: "LFS_SuperBlockInfoKey",
	11: "LFS_BucketInfoKey",
	12: "LFS_ObjectInfoKey",
	13: "LFS_BucketOptionKey",
	14: "LFS_OpInfoKey",
	15: "LFS_OpJobsKey",
	16: "LFS_OpStateKey",
	17: "LFS_OpCountKey",
	20: "ST_PDPPublicKey",
	21: "ST_BucketOptKey",
	22: "ST_OrderBaseKey",
	23: "ST_OrderSeqKey",
	24: "ST_SegLocKey",
	25: "St_SegMapKey",
	30: "ST_RootKey",
	31: "ST_BlockHeightKey",
	32: "ST_EpochKey",
	40: "SegLocationKey",
	41: "Chal_UsersKey",
	42: "Chal_ProofKey",
	43: "Chal_BucketInfoKey",
	50: "OrderNonceKey",
	51: "OrderBaseKey",
	52: "OrderSeqNumKey",
	53: "OrderSeqKey",
	54: "OrderProsKey",
	55: "OrderUsersKey",
	60: "Tx_BlockSyncedKey",
	61: "TX_BlockKey",
	62: "Tx_BlockHeightKey",
	63: "Tx_NonceKey",
	64: "TX_MessageKey",
	65: "Tx_MessageStateKey",
}

var MetaType_value = map[string]int32{
	"Unknown":               0,
	"RoleInfoKey":           1,
	"NetInfoKey":            2,
	"LFS_SuperBlockInfoKey": 10,
	"LFS_BucketInfoKey":     11,
	"LFS_ObjectInfoKey":     12,
	"LFS_BucketOptionKey":   13,
	"LFS_OpInfoKey":         14,
	"LFS_OpJobsKey":         15,
	"LFS_OpStateKey":        16,
	"LFS_OpCountKey":        17,
	"ST_PDPPublicKey":       20,
	"ST_BucketOptKey":       21,
	"ST_OrderBaseKey":       22,
	"ST_OrderSeqKey":        23,
	"ST_SegLocKey":          24,
	"St_SegMapKey":          25,
	"ST_RootKey":            30,
	"ST_BlockHeightKey":     31,
	"ST_EpochKey":           32,
	"SegLocationKey":        40,
	"Chal_UsersKey":         41,
	"Chal_ProofKey":         42,
	"Chal_BucketInfoKey":    43,
	"OrderNonceKey":         50,
	"OrderBaseKey":          51,
	"OrderSeqNumKey":        52,
	"OrderSeqKey":           53,
	"OrderProsKey":          54,
	"OrderUsersKey":         55,
	"Tx_BlockSyncedKey":     60,
	"TX_BlockKey":           61,
	"Tx_BlockHeightKey":     62,
	"Tx_NonceKey":           63,
	"TX_MessageKey":         64,
	"Tx_MessageStateKey":    65,
}

func (x MetaType) String() string {
	return proto.EnumName(MetaType_name, int32(x))
}

func (MetaType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{0}
}

type OpRecord_OpType int32

const (
	OpRecord_Unknown      OpRecord_OpType = 0
	OpRecord_CreateObject OpRecord_OpType = 1
	OpRecord_AddData      OpRecord_OpType = 2
	OpRecord_DeleteObject OpRecord_OpType = 3
)

var OpRecord_OpType_name = map[int32]string{
	0: "Unknown",
	1: "CreateObject",
	2: "AddData",
	3: "DeleteObject",
}

var OpRecord_OpType_value = map[string]int32{
	"Unknown":      0,
	"CreateObject": 1,
	"AddData":      2,
	"DeleteObject": 3,
}

func (x OpRecord_OpType) String() string {
	return proto.EnumName(OpRecord_OpType_name, int32(x))
}

func (OpRecord_OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{7, 0}
}

// 'SuperBlockInfoKey'/fsID
type SuperBlockInfo struct {
	Version              uint32   `protobuf:"varint,1,opt,name=Version,json=version,proto3" json:"Version,omitempty"`
	ReplicaNum           uint32   `protobuf:"varint,2,opt,name=ReplicaNum,json=replicaNum,proto3" json:"ReplicaNum,omitempty"`
	NextBucketID         uint64   `protobuf:"varint,3,opt,name=NextBucketID,json=nextBucketID,proto3" json:"NextBucketID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SuperBlockInfo) Reset()         { *m = SuperBlockInfo{} }
func (m *SuperBlockInfo) String() string { return proto.CompactTextString(m) }
func (*SuperBlockInfo) ProtoMessage()    {}
func (*SuperBlockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{0}
}
func (m *SuperBlockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuperBlockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuperBlockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuperBlockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuperBlockInfo.Merge(m, src)
}
func (m *SuperBlockInfo) XXX_Size() int {
	return m.Size()
}
func (m *SuperBlockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SuperBlockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SuperBlockInfo proto.InternalMessageInfo

func (m *SuperBlockInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SuperBlockInfo) GetReplicaNum() uint32 {
	if m != nil {
		return m.ReplicaNum
	}
	return 0
}

func (m *SuperBlockInfo) GetNextBucketID() uint64 {
	if m != nil {
		return m.NextBucketID
	}
	return 0
}

// 'BucketCountKey'/fsID
// 'StripeCountKey'/fsID/bucketID
// key: 'BucketOptionKey'/fsID/bucketID
type BucketOption struct {
	Version              uint32   `protobuf:"varint,1,opt,name=Version,json=version,proto3" json:"Version,omitempty"`
	Policy               uint32   `protobuf:"varint,2,opt,name=Policy,json=policy,proto3" json:"Policy,omitempty"`
	DataCount            uint32   `protobuf:"varint,3,opt,name=DataCount,json=dataCount,proto3" json:"DataCount,omitempty"`
	ParityCount          uint32   `protobuf:"varint,4,opt,name=ParityCount,json=parityCount,proto3" json:"ParityCount,omitempty"`
	TagFlag              uint32   `protobuf:"varint,5,opt,name=TagFlag,json=tagFlag,proto3" json:"TagFlag,omitempty"`
	SegSize              uint32   `protobuf:"varint,6,opt,name=SegSize,json=segSize,proto3" json:"SegSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BucketOption) Reset()         { *m = BucketOption{} }
func (m *BucketOption) String() string { return proto.CompactTextString(m) }
func (*BucketOption) ProtoMessage()    {}
func (*BucketOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{1}
}
func (m *BucketOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketOption.Merge(m, src)
}
func (m *BucketOption) XXX_Size() int {
	return m.Size()
}
func (m *BucketOption) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketOption.DiscardUnknown(m)
}

var xxx_messageInfo_BucketOption proto.InternalMessageInfo

func (m *BucketOption) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BucketOption) GetPolicy() uint32 {
	if m != nil {
		return m.Policy
	}
	return 0
}

func (m *BucketOption) GetDataCount() uint32 {
	if m != nil {
		return m.DataCount
	}
	return 0
}

func (m *BucketOption) GetParityCount() uint32 {
	if m != nil {
		return m.ParityCount
	}
	return 0
}

func (m *BucketOption) GetTagFlag() uint32 {
	if m != nil {
		return m.TagFlag
	}
	return 0
}

func (m *BucketOption) GetSegSize() uint32 {
	if m != nil {
		return m.SegSize
	}
	return 0
}

// key: 'BucketInfoKey'/fsID/bucketID
type BucketInfo struct {
	BucketID             uint64   `protobuf:"varint,1,opt,name=BucketID,json=bucketID,proto3" json:"BucketID,omitempty"`
	CTime                int64    `protobuf:"varint,2,opt,name=CTime,json=cTime,proto3" json:"CTime,omitempty"`
	MTime                int64    `protobuf:"varint,3,opt,name=MTime,json=mTime,proto3" json:"MTime,omitempty"`
	Length               uint64   `protobuf:"varint,4,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	UsedBytes            uint64   `protobuf:"varint,5,opt,name=UsedBytes,json=usedBytes,proto3" json:"UsedBytes,omitempty"`
	NextObjectID         uint64   `protobuf:"varint,6,opt,name=NextObjectID,json=nextObjectID,proto3" json:"NextObjectID,omitempty"`
	NextOpID             uint64   `protobuf:"varint,7,opt,name=NextOpID,json=nextOpID,proto3" json:"NextOpID,omitempty"`
	Deletion             bool     `protobuf:"varint,8,opt,name=deletion,proto3" json:"deletion,omitempty"`
	Name                 string   `protobuf:"bytes,9,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
	Root                 []byte   `protobuf:"bytes,10,opt,name=Root,json=root,proto3" json:"Root,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BucketInfo) Reset()         { *m = BucketInfo{} }
func (m *BucketInfo) String() string { return proto.CompactTextString(m) }
func (*BucketInfo) ProtoMessage()    {}
func (*BucketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{2}
}
func (m *BucketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketInfo.Merge(m, src)
}
func (m *BucketInfo) XXX_Size() int {
	return m.Size()
}
func (m *BucketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BucketInfo proto.InternalMessageInfo

func (m *BucketInfo) GetBucketID() uint64 {
	if m != nil {
		return m.BucketID
	}
	return 0
}

func (m *BucketInfo) GetCTime() int64 {
	if m != nil {
		return m.CTime
	}
	return 0
}

func (m *BucketInfo) GetMTime() int64 {
	if m != nil {
		return m.MTime
	}
	return 0
}

func (m *BucketInfo) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *BucketInfo) GetUsedBytes() uint64 {
	if m != nil {
		return m.UsedBytes
	}
	return 0
}

func (m *BucketInfo) GetNextObjectID() uint64 {
	if m != nil {
		return m.NextObjectID
	}
	return 0
}

func (m *BucketInfo) GetNextOpID() uint64 {
	if m != nil {
		return m.NextOpID
	}
	return 0
}

func (m *BucketInfo) GetDeletion() bool {
	if m != nil {
		return m.Deletion
	}
	return false
}

func (m *BucketInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BucketInfo) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

type ObjectForm struct {
	OpRecord             []uint64 `protobuf:"varint,1,rep,packed,name=OpRecord,json=opRecord,proto3" json:"OpRecord,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectForm) Reset()         { *m = ObjectForm{} }
func (m *ObjectForm) String() string { return proto.CompactTextString(m) }
func (*ObjectForm) ProtoMessage()    {}
func (*ObjectForm) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{3}
}
func (m *ObjectForm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectForm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectForm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectForm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectForm.Merge(m, src)
}
func (m *ObjectForm) XXX_Size() int {
	return m.Size()
}
func (m *ObjectForm) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectForm.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectForm proto.InternalMessageInfo

func (m *ObjectForm) GetOpRecord() []uint64 {
	if m != nil {
		return m.OpRecord
	}
	return nil
}

// object information; when create object
type ObjectInfo struct {
	ObjectID             uint64   `protobuf:"varint,1,opt,name=ObjectID,json=objectID,proto3" json:"ObjectID,omitempty"`
	BucketID             uint64   `protobuf:"varint,2,opt,name=BucketID,json=bucketID,proto3" json:"BucketID,omitempty"`
	Time                 int64    `protobuf:"varint,3,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Expire               uint64   `protobuf:"varint,4,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	Name                 string   `protobuf:"bytes,5,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
	Encryption           string   `protobuf:"bytes,6,opt,name=Encryption,json=encryption,proto3" json:"Encryption,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectInfo) Reset()         { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()    {}
func (*ObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{4}
}
func (m *ObjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectInfo.Merge(m, src)
}
func (m *ObjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectInfo proto.InternalMessageInfo

func (m *ObjectInfo) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *ObjectInfo) GetBucketID() uint64 {
	if m != nil {
		return m.BucketID
	}
	return 0
}

func (m *ObjectInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ObjectInfo) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *ObjectInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectInfo) GetEncryption() string {
	if m != nil {
		return m.Encryption
	}
	return ""
}

// object delete information; when delete object
type ObjectDeleteInfo struct {
	ObjectID             uint64   `protobuf:"varint,1,opt,name=ObjectID,json=objectID,proto3" json:"ObjectID,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectDeleteInfo) Reset()         { *m = ObjectDeleteInfo{} }
func (m *ObjectDeleteInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectDeleteInfo) ProtoMessage()    {}
func (*ObjectDeleteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{5}
}
func (m *ObjectDeleteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectDeleteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectDeleteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectDeleteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectDeleteInfo.Merge(m, src)
}
func (m *ObjectDeleteInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectDeleteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectDeleteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectDeleteInfo proto.InternalMessageInfo

func (m *ObjectDeleteInfo) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *ObjectDeleteInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// opart informations, insert into object when add data to an existing object
type ObjectPartInfo struct {
	ObjectID             uint64   `protobuf:"varint,1,opt,name=ObjectID,json=objectID,proto3" json:"ObjectID,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Offset               uint64   `protobuf:"varint,3,opt,name=Offset,json=offset,proto3" json:"Offset,omitempty"`
	Length               uint64   `protobuf:"varint,4,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	RawLength            uint64   `protobuf:"varint,5,opt,name=RawLength,json=rawLength,proto3" json:"RawLength,omitempty"`
	ETag                 []byte   `protobuf:"bytes,7,opt,name=ETag,json=eTag,proto3" json:"ETag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectPartInfo) Reset()         { *m = ObjectPartInfo{} }
func (m *ObjectPartInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectPartInfo) ProtoMessage()    {}
func (*ObjectPartInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{6}
}
func (m *ObjectPartInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectPartInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectPartInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectPartInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectPartInfo.Merge(m, src)
}
func (m *ObjectPartInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectPartInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectPartInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectPartInfo proto.InternalMessageInfo

func (m *ObjectPartInfo) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *ObjectPartInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ObjectPartInfo) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ObjectPartInfo) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *ObjectPartInfo) GetRawLength() uint64 {
	if m != nil {
		return m.RawLength
	}
	return 0
}

func (m *ObjectPartInfo) GetETag() []byte {
	if m != nil {
		return m.ETag
	}
	return nil
}

// 'OpDoneKey'/fsID/bucketID
// 'OpCountKey'/fsID/bucketID
// key: 'OpInfoKey'/fsID/bucketID/opID
type OpRecord struct {
	Type                 OpRecord_OpType `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=pb.OpRecord_OpType" json:"Type,omitempty"`
	OpID                 uint64          `protobuf:"varint,2,opt,name=OpID,json=opID,proto3" json:"OpID,omitempty"`
	Time                 int64           `protobuf:"varint,3,opt,name=Time,json=time,proto3" json:"Time,omitempty"`
	Payload              []byte          `protobuf:"bytes,4,opt,name=Payload,json=payload,proto3" json:"Payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *OpRecord) Reset()         { *m = OpRecord{} }
func (m *OpRecord) String() string { return proto.CompactTextString(m) }
func (*OpRecord) ProtoMessage()    {}
func (*OpRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{7}
}
func (m *OpRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpRecord.Merge(m, src)
}
func (m *OpRecord) XXX_Size() int {
	return m.Size()
}
func (m *OpRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_OpRecord.DiscardUnknown(m)
}

var xxx_messageInfo_OpRecord proto.InternalMessageInfo

func (m *OpRecord) GetType() OpRecord_OpType {
	if m != nil {
		return m.Type
	}
	return OpRecord_Unknown
}

func (m *OpRecord) GetOpID() uint64 {
	if m != nil {
		return m.OpID
	}
	return 0
}

func (m *OpRecord) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *OpRecord) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// key: 'SegExpireKey'/fsID_bucketID_stripeID
type SegExpire struct {
	Length               uint64   `protobuf:"varint,1,opt,name=Length,json=length,proto3" json:"Length,omitempty"`
	Expire               uint64   `protobuf:"varint,2,opt,name=Expire,json=expire,proto3" json:"Expire,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SegExpire) Reset()         { *m = SegExpire{} }
func (m *SegExpire) String() string { return proto.CompactTextString(m) }
func (*SegExpire) ProtoMessage()    {}
func (*SegExpire) Descriptor() ([]byte, []int) {
	return fileDescriptor_e604833c2b457e38, []int{8}
}
func (m *SegExpire) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegExpire) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegExpire.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegExpire) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegExpire.Merge(m, src)
}
func (m *SegExpire) XXX_Size() int {
	return m.Size()
}
func (m *SegExpire) XXX_DiscardUnknown() {
	xxx_messageInfo_SegExpire.DiscardUnknown(m)
}

var xxx_messageInfo_SegExpire proto.InternalMessageInfo

func (m *SegExpire) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SegExpire) GetExpire() uint64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func init() {
	proto.RegisterEnum("pb.MetaType", MetaType_name, MetaType_value)
	proto.RegisterEnum("pb.OpRecord_OpType", OpRecord_OpType_name, OpRecord_OpType_value)
	proto.RegisterType((*SuperBlockInfo)(nil), "pb.SuperBlockInfo")
	proto.RegisterType((*BucketOption)(nil), "pb.BucketOption")
	proto.RegisterType((*BucketInfo)(nil), "pb.BucketInfo")
	proto.RegisterType((*ObjectForm)(nil), "pb.ObjectForm")
	proto.RegisterType((*ObjectInfo)(nil), "pb.ObjectInfo")
	proto.RegisterType((*ObjectDeleteInfo)(nil), "pb.ObjectDeleteInfo")
	proto.RegisterType((*ObjectPartInfo)(nil), "pb.ObjectPartInfo")
	proto.RegisterType((*OpRecord)(nil), "pb.OpRecord")
	proto.RegisterType((*SegExpire)(nil), "pb.SegExpire")
}

func init() { proto.RegisterFile("fs.proto", fileDescriptor_e604833c2b457e38) }

var fileDescriptor_e604833c2b457e38 = []byte{
	// 980 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0xc7, 0x77, 0xec, 0xf1, 0x57, 0xd9, 0x71, 0x9c, 0xce, 0x26, 0x3b, 0x8b, 0x90, 0xb1, 0xe6,
	0x82, 0x59, 0xa4, 0x1c, 0x76, 0xf9, 0x38, 0xf0, 0xb9, 0x8e, 0x13, 0x11, 0x48, 0x6c, 0x6b, 0x66,
	0x82, 0xf6, 0x66, 0xb5, 0xc7, 0xed, 0x89, 0xc9, 0x78, 0xba, 0x99, 0x69, 0xb3, 0x36, 0x0f, 0xc1,
	0x99, 0x33, 0xe2, 0x11, 0xb8, 0x72, 0xe7, 0x88, 0xc4, 0x0b, 0xa0, 0xf0, 0x22, 0xa8, 0xba, 0xe7,
	0xc3, 0x01, 0x2d, 0x48, 0x7b, 0xac, 0x5f, 0xb5, 0xab, 0xfe, 0xf5, 0xef, 0x9a, 0x36, 0xd4, 0x17,
	0xc9, 0x89, 0x88, 0xb9, 0xe4, 0xa4, 0x24, 0x66, 0x76, 0x04, 0x6d, 0x77, 0x2d, 0x58, 0x3c, 0x08,
	0xb9, 0x7f, 0x7b, 0x11, 0x2d, 0x38, 0xb1, 0xa0, 0xf6, 0x35, 0x8b, 0x93, 0x25, 0x8f, 0x2c, 0xa3,
	0x67, 0xf4, 0xf7, 0x9c, 0xda, 0x77, 0x3a, 0x24, 0x5d, 0x00, 0x87, 0x89, 0x70, 0xe9, 0xd3, 0xd1,
	0x7a, 0x65, 0x95, 0x54, 0x12, 0xe2, 0x9c, 0x10, 0x1b, 0x5a, 0x23, 0xb6, 0x91, 0x83, 0xb5, 0x7f,
	0xcb, 0xe4, 0xc5, 0xd0, 0x2a, 0xf7, 0x8c, 0xbe, 0xe9, 0xb4, 0xa2, 0x1d, 0x66, 0xff, 0x62, 0x40,
	0x4b, 0x07, 0x63, 0x21, 0xb1, 0xe8, 0xab, 0xdb, 0x1d, 0x43, 0x75, 0xc2, 0xc3, 0xa5, 0xbf, 0x4d,
	0x5b, 0x55, 0x85, 0x8a, 0xc8, 0x9b, 0xd0, 0x18, 0x52, 0x49, 0x4f, 0xf9, 0x3a, 0x92, 0xaa, 0xc7,
	0x9e, 0xd3, 0x98, 0x67, 0x80, 0xf4, 0xa0, 0x39, 0xa1, 0xf1, 0x52, 0x6e, 0x75, 0xde, 0x54, 0xf9,
	0xa6, 0x28, 0x10, 0x76, 0xf4, 0x68, 0x70, 0x1e, 0xd2, 0xc0, 0xaa, 0xe8, 0x8e, 0x52, 0x87, 0x98,
	0x71, 0x59, 0xe0, 0x2e, 0xbf, 0x67, 0x56, 0x55, 0x67, 0x12, 0x1d, 0xda, 0x3f, 0x94, 0x00, 0xd2,
	0x19, 0xd0, 0xa3, 0x37, 0xa0, 0x9e, 0x4f, 0x69, 0xa8, 0x29, 0xeb, 0xb3, 0x34, 0x26, 0x0f, 0xa1,
	0x72, 0xea, 0x2d, 0x57, 0x4c, 0xa9, 0x2e, 0x3b, 0x15, 0x1f, 0x03, 0xa4, 0x57, 0x8a, 0x96, 0x35,
	0x5d, 0x29, 0x7a, 0x0c, 0xd5, 0x4b, 0x16, 0x05, 0xf2, 0x46, 0xe9, 0x34, 0x9d, 0x6a, 0xa8, 0x22,
	0x1c, 0xf1, 0x3a, 0x61, 0xf3, 0xc1, 0x56, 0xb2, 0x44, 0x89, 0x34, 0x9d, 0xc6, 0x3a, 0x03, 0x99,
	0xcf, 0xe3, 0xd9, 0x37, 0xcc, 0x47, 0x05, 0xd5, 0xc2, 0xe7, 0x8c, 0xa1, 0x42, 0x75, 0x46, 0x5c,
	0x0c, 0xad, 0x9a, 0x56, 0x18, 0xa5, 0x31, 0xe6, 0xe6, 0x2c, 0x64, 0x68, 0xbf, 0x55, 0xef, 0x19,
	0xfd, 0xba, 0x93, 0xc7, 0x84, 0x80, 0x39, 0xa2, 0x2b, 0x66, 0x35, 0x7a, 0x46, 0xbf, 0xe1, 0x98,
	0x11, 0x5d, 0x31, 0x64, 0x0e, 0xe7, 0xd2, 0x82, 0x9e, 0xd1, 0x6f, 0x39, 0x66, 0xcc, 0xb9, 0xb4,
	0xfb, 0x00, 0xba, 0xd7, 0x39, 0x8f, 0x57, 0x58, 0x71, 0x2c, 0x1c, 0xe6, 0xf3, 0x78, 0x6e, 0x19,
	0xbd, 0x32, 0x76, 0xe3, 0x69, 0x6c, 0xff, 0x6c, 0x64, 0x47, 0x33, 0xeb, 0x72, 0xe1, 0xa9, 0x75,
	0x7c, 0x47, 0x74, 0x6e, 0x6b, 0xe9, 0x1f, 0xb6, 0x12, 0x30, 0x77, 0xfc, 0x33, 0x65, 0x6a, 0xdf,
	0xd9, 0x46, 0x2c, 0x63, 0x96, 0xd9, 0xc7, 0x54, 0x94, 0x0f, 0x51, 0xd9, 0x19, 0xa2, 0x0b, 0x70,
	0x16, 0xf9, 0xf1, 0x56, 0x6d, 0x9d, 0xb2, 0xac, 0xe1, 0x00, 0xcb, 0x89, 0x3d, 0x80, 0x8e, 0xd6,
	0x35, 0x44, 0x2b, 0xd8, 0xff, 0x6a, 0xcd, 0xf4, 0x94, 0x0a, 0x3d, 0xf6, 0x4f, 0x06, 0xb4, 0xf5,
	0x0f, 0x26, 0x34, 0x96, 0xaf, 0x53, 0x02, 0x47, 0x1a, 0x2f, 0x16, 0x09, 0x93, 0xe9, 0xd7, 0x53,
	0xe5, 0x2a, 0xfa, 0xaf, 0x4d, 0x71, 0xe8, 0xcb, 0x34, 0x95, 0x6e, 0x4a, 0x9c, 0x01, 0xec, 0x70,
	0xe6, 0xd1, 0x40, 0x6d, 0x40, 0xcb, 0x31, 0x99, 0x47, 0x03, 0xfb, 0x57, 0xa3, 0xb8, 0x2c, 0xf2,
	0x36, 0x98, 0xde, 0x56, 0x30, 0x25, 0xad, 0xfd, 0xf4, 0xf0, 0x44, 0xcc, 0x4e, 0xb2, 0xdc, 0xc9,
	0x58, 0x60, 0xca, 0x31, 0xe5, 0x56, 0x28, 0x4b, 0xd5, 0x2e, 0xe9, 0x6b, 0x31, 0xb9, 0x78, 0xc5,
	0x95, 0x58, 0x50, 0x9b, 0xd0, 0x6d, 0xc8, 0xe9, 0x5c, 0x09, 0x6d, 0x39, 0x35, 0xa1, 0x43, 0xfb,
	0x1c, 0xaa, 0xba, 0x22, 0x69, 0x42, 0xed, 0x3a, 0xba, 0x8d, 0xf8, 0xcb, 0xa8, 0xf3, 0x80, 0x74,
	0xa0, 0x75, 0x1a, 0x33, 0x2a, 0x99, 0xb6, 0xa9, 0x63, 0x60, 0xfa, 0xf9, 0x7c, 0x8e, 0x9f, 0x78,
	0xa7, 0x84, 0x69, 0x7d, 0x21, 0x69, 0xba, 0x6c, 0x7f, 0x04, 0x0d, 0x97, 0x05, 0xfa, 0xde, 0x77,
	0x6c, 0x31, 0xee, 0xd9, 0x52, 0x6c, 0x46, 0x69, 0x77, 0x33, 0x9e, 0xfc, 0x51, 0x81, 0xfa, 0x15,
	0x93, 0xf4, 0xdf, 0x3a, 0xf6, 0xa1, 0xe9, 0xf0, 0x50, 0xdd, 0xfb, 0x57, 0x6c, 0xdb, 0x31, 0x48,
	0x1b, 0x60, 0xa4, 0x3f, 0x77, 0x8c, 0x4b, 0xe4, 0x31, 0x1c, 0x5d, 0x9e, 0xbb, 0xd3, 0xfb, 0xaf,
	0x25, 0xa6, 0x80, 0x1c, 0xc1, 0x01, 0xa6, 0x8a, 0x07, 0x02, 0x71, 0x33, 0xc3, 0xc5, 0xf2, 0x23,
	0x6e, 0x91, 0x47, 0x70, 0x58, 0x9c, 0xd6, 0xaf, 0x20, 0x26, 0xf6, 0xc8, 0x01, 0xec, 0xa9, 0xf3,
	0x22, 0x3b, 0xdb, 0x2e, 0xd0, 0x97, 0x7c, 0x96, 0x20, 0xda, 0x27, 0x04, 0xda, 0x1a, 0xb9, 0x92,
	0x4a, 0x86, 0xac, 0x53, 0x30, 0xf5, 0xc2, 0x21, 0x3b, 0x20, 0x87, 0xb0, 0xef, 0x7a, 0xd3, 0xc9,
	0x70, 0x32, 0x59, 0xcf, 0xc2, 0xa5, 0x8f, 0xf0, 0x61, 0x0a, 0xf3, 0xd6, 0x08, 0x8f, 0x52, 0x38,
	0x8e, 0xe7, 0x2c, 0x1e, 0xd0, 0x44, 0x95, 0x3c, 0xc6, 0x92, 0x19, 0x74, 0xd9, 0xb7, 0xc8, 0x1e,
	0xe1, 0x65, 0xb8, 0xde, 0xd4, 0x65, 0xc1, 0x25, 0x57, 0xf5, 0x2c, 0x45, 0x24, 0x92, 0x2b, 0x2a,
	0x90, 0x3c, 0x46, 0xdb, 0x5c, 0x6f, 0x8a, 0xef, 0x05, 0xc6, 0x5d, 0x34, 0x01, 0x3b, 0xa2, 0x61,
	0x5f, 0xb0, 0x65, 0x70, 0xa3, 0xf0, 0x5b, 0x68, 0xb7, 0xeb, 0x4d, 0xcf, 0x04, 0xf7, 0x6f, 0x10,
	0xf4, 0x54, 0x3f, 0x55, 0x98, 0x66, 0x86, 0xf4, 0x71, 0xfa, 0xd3, 0x1b, 0x1a, 0x4e, 0xaf, 0x13,
	0x16, 0xab, 0xe9, 0xdf, 0xc9, 0xd1, 0x24, 0xe6, 0x7c, 0x81, 0xe8, 0x09, 0x39, 0x06, 0xa2, 0xd0,
	0x7d, 0xfb, 0xdf, 0xc5, 0xa3, 0x4a, 0xfe, 0x88, 0x47, 0xbe, 0x1a, 0xea, 0x29, 0xca, 0xbd, 0x37,
	0xe6, 0x33, 0x6c, 0x9b, 0xcd, 0x38, 0x5a, 0xaf, 0x90, 0xbd, 0x87, 0xda, 0x76, 0xe7, 0x7e, 0x3f,
	0xff, 0xd9, 0x24, 0xe6, 0x4a, 0xc6, 0x07, 0x79, 0xed, 0x5c, 0xd9, 0x87, 0x38, 0xa8, 0xb7, 0xd1,
	0x83, 0xba, 0xdb, 0xc8, 0x67, 0x73, 0xc4, 0x1f, 0x63, 0x31, 0xef, 0x85, 0xc6, 0x08, 0x3e, 0xd9,
	0x3d, 0x57, 0x18, 0xf2, 0xa9, 0x3a, 0xb7, 0x99, 0xe6, 0x5a, 0x3f, 0xc3, 0x16, 0xde, 0x8b, 0xe9,
	0x15, 0x4b, 0x12, 0x1a, 0x28, 0xf4, 0x39, 0x4e, 0xea, 0x6d, 0x32, 0x94, 0x5f, 0xff, 0xf3, 0x41,
	0xe7, 0xb7, 0xbb, 0xae, 0xf1, 0xfb, 0x5d, 0xd7, 0xf8, 0xf3, 0xae, 0x6b, 0xfc, 0xf8, 0x57, 0xf7,
	0xc1, 0xac, 0xaa, 0xfe, 0xe1, 0x9f, 0xfd, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x6e, 0x6c, 0x53, 0xba,
	0xed, 0x07, 0x00, 0x00,
}

func (m *SuperBlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuperBlockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuperBlockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NextBucketID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.NextBucketID))
		i--
		dAtA[i] = 0x18
	}
	if m.ReplicaNum != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ReplicaNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BucketOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SegSize != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.SegSize))
		i--
		dAtA[i] = 0x30
	}
	if m.TagFlag != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.TagFlag))
		i--
		dAtA[i] = 0x28
	}
	if m.ParityCount != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ParityCount))
		i--
		dAtA[i] = 0x20
	}
	if m.DataCount != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.DataCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Policy != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BucketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Deletion {
		i--
		if m.Deletion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.NextOpID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.NextOpID))
		i--
		dAtA[i] = 0x38
	}
	if m.NextObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.NextObjectID))
		i--
		dAtA[i] = 0x30
	}
	if m.UsedBytes != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.UsedBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.MTime != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.MTime))
		i--
		dAtA[i] = 0x18
	}
	if m.CTime != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.CTime))
		i--
		dAtA[i] = 0x10
	}
	if m.BucketID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.BucketID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectForm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectForm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectForm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OpRecord) > 0 {
		dAtA2 := make([]byte, len(m.OpRecord)*10)
		var j1 int
		for _, num := range m.OpRecord {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintFs(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Encryption) > 0 {
		i -= len(m.Encryption)
		copy(dAtA[i:], m.Encryption)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Encryption)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x20
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.BucketID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.BucketID))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectDeleteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectDeleteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectDeleteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectPartInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectPartInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectPartInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ETag) > 0 {
		i -= len(m.ETag)
		copy(dAtA[i:], m.ETag)
		i = encodeVarintFs(dAtA, i, uint64(len(m.ETag)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RawLength != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.RawLength))
		i--
		dAtA[i] = 0x28
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintFs(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if m.Time != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.OpID != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.OpID))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegExpire) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegExpire) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegExpire) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expire != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x10
	}
	if m.Length != 0 {
		i = encodeVarintFs(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFs(dAtA []byte, offset int, v uint64) int {
	offset -= sovFs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SuperBlockInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovFs(uint64(m.Version))
	}
	if m.ReplicaNum != 0 {
		n += 1 + sovFs(uint64(m.ReplicaNum))
	}
	if m.NextBucketID != 0 {
		n += 1 + sovFs(uint64(m.NextBucketID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BucketOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovFs(uint64(m.Version))
	}
	if m.Policy != 0 {
		n += 1 + sovFs(uint64(m.Policy))
	}
	if m.DataCount != 0 {
		n += 1 + sovFs(uint64(m.DataCount))
	}
	if m.ParityCount != 0 {
		n += 1 + sovFs(uint64(m.ParityCount))
	}
	if m.TagFlag != 0 {
		n += 1 + sovFs(uint64(m.TagFlag))
	}
	if m.SegSize != 0 {
		n += 1 + sovFs(uint64(m.SegSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BucketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BucketID != 0 {
		n += 1 + sovFs(uint64(m.BucketID))
	}
	if m.CTime != 0 {
		n += 1 + sovFs(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovFs(uint64(m.MTime))
	}
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.UsedBytes != 0 {
		n += 1 + sovFs(uint64(m.UsedBytes))
	}
	if m.NextObjectID != 0 {
		n += 1 + sovFs(uint64(m.NextObjectID))
	}
	if m.NextOpID != 0 {
		n += 1 + sovFs(uint64(m.NextOpID))
	}
	if m.Deletion {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectForm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OpRecord) > 0 {
		l = 0
		for _, e := range m.OpRecord {
			l += sovFs(uint64(e))
		}
		n += 1 + sovFs(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovFs(uint64(m.ObjectID))
	}
	if m.BucketID != 0 {
		n += 1 + sovFs(uint64(m.BucketID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	l = len(m.Encryption)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectDeleteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovFs(uint64(m.ObjectID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectPartInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovFs(uint64(m.ObjectID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	if m.Offset != 0 {
		n += 1 + sovFs(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.RawLength != 0 {
		n += 1 + sovFs(uint64(m.RawLength))
	}
	l = len(m.ETag)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFs(uint64(m.Type))
	}
	if m.OpID != 0 {
		n += 1 + sovFs(uint64(m.OpID))
	}
	if m.Time != 0 {
		n += 1 + sovFs(uint64(m.Time))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegExpire) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovFs(uint64(m.Length))
	}
	if m.Expire != 0 {
		n += 1 + sovFs(uint64(m.Expire))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFs(x uint64) (n int) {
	return sovFs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SuperBlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuperBlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuperBlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNum", wireType)
			}
			m.ReplicaNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextBucketID", wireType)
			}
			m.NextBucketID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextBucketID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCount", wireType)
			}
			m.DataCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityCount", wireType)
			}
			m.ParityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParityCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagFlag", wireType)
			}
			m.TagFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegSize", wireType)
			}
			m.SegSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketID", wireType)
			}
			m.BucketID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			m.UsedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextObjectID", wireType)
			}
			m.NextObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextOpID", wireType)
			}
			m.NextOpID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextOpID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deletion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deletion = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectForm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectForm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectForm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OpRecord = append(m.OpRecord, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFs
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFs
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OpRecord) == 0 {
					m.OpRecord = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OpRecord = append(m.OpRecord, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OpRecord", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketID", wireType)
			}
			m.BucketID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encryption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectDeleteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectDeleteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectDeleteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectPartInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectPartInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectPartInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawLength", wireType)
			}
			m.RawLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ETag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ETag = append(m.ETag[:0], dAtA[iNdEx:postIndex]...)
			if m.ETag == nil {
				m.ETag = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= OpRecord_OpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpID", wireType)
			}
			m.OpID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegExpire) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegExpire: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegExpire: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFs = fmt.Errorf("proto: unexpected end of group")
)
