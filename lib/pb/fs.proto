// `protoc --gofast_out=. *.proto`
syntax = "proto3";
package pb;

// kv key type 
enum MetaType {
    Unknown = 0;

	LocalNetKey = 1;          // key: x; val: local netid and its private key
	LocalAddrKey = 2;         // key: x; val: chain address
	RoleInfoKey = 3;          // key: x/id; val: RoleInfo
	NetInfoKey = 4;           // key: x/netid; val: NetInfo

    PDPProveKey = 5;          // key: x/userID; val: Bls Prove key set, sign; gen proof on provider
	PDPVerifyKey = 6;         // key: x/userID; val: Bls Verify key set, verify proof
	FsMemberKey = 7;          // key: x/userID: val: keepers/providers

   	// lfs meta
	LFS_SuperBlockInfoKey = 10; // key: x/userID; val: SuperBlockInfo
	LFS_BucketInfoKey = 11;     // key: x/userID/bucketID; val: BucketInfo
	LFS_ObjectInfoKey = 12;     // key: x/userID/bucketID/objectID; val: OpIDs
	
    LFS_BucketOptionKey = 13; // key: x/userID/bucketID; val: BucketOption 
    LFS_OpInfoKey = 14;       // key: x/userID/bucketID/opID; val: BucketRecord
    LFS_OpStateKey = 16;		  // key: x/userID/bucketID/opID; val: opstate	 
    LFS_OpCountKey = 17;      // key: x/userID/bucketID; val: op number

	// key in state tree
	ST_GasMoneyKey = 20;     // key: x/type/id; val: gasMoney  
	ST_RoleInfoKey = 21;     // key: x/type/id; val: roleInfo
	ST_BucketOptKey = 23;    // key: x/userID/bucketID; val: bucket option
	ST_SegLocKey = 24;       // key: x/userID/bucketID/chunkID/stripeID; value: length, proID
	ST_SegExpireKey = 25;    // key: x/userID/bucketID/stripeID; value: length, expire
	ST_PieceLocKey = 26;     // key: x/pieceID; value: userID, size, expire, proIDs, price, states	
	ST_SectorInfoKey = 27;   // key: x/proID/sectorID; val: SectorInfo	
	ST_DataOrderKey = 30;    // key: x/userID/proID/nonce; value: OrderBase, seqnum, psize, ssize, []dataName, psize(lost), ssize(lost), []dataName(lost);

	ST_EpochKey = 31;        // key: x; val: l3, l2, last, current 
	//ST_ChalSeedKey = 32;     // key: x/epoch; val: height, seed, time
	ST_IncomeKey = 33;       // key: x/proID/epoch; value: expected(lifecycle), income, lost, []sign
	ST_ChalSegResKey = 34;   // key: x/proID/userID/epoch; value: proof	  
	ST_ChalSecResKey = 35;   // key: x/proID/epoch; value: proof	
	
	// data meta
    PieceInfoKey = 40;      // key: x/pieceID; val: PieceInfo; on provider    
    SectorPiecesKey = 41;   // key: x/sectorID, val: SectorPieces; on provider
    SectorCountKey = 42;    // key: x/proID, val: sectorNumber; on keeper and provider
    SectorSetKey = 43;      // key: x/proID, val: sectorSet; on keeper and provider
	OrderTxKey = 44;        // key: x/userID/proID/nonce; val: []txHash;

	SegLocationKey = 45;    // key: x/segID; val: proID

	// order
	OrderNonceKey = 50;      // key: x/userID/proID; value: nonce, OrderBaseState
	OrderBaseKey = 51;       // key: x/userID/proID/nonce; value: OrderBase
	OrderSeqNumKey = 52;     // key: x/userID/proID/nonce; value: seqnum, OrderSeqState
	OrderSeqKey = 53;        // key: x/userID/proID/nonce/seqnum; value: OrderSeq
	OrderProsKey = 54;       // key: x/userID; value: pros
		
	TX_MessageKey = 60;       // key: x/messageHash; value: message content, sign
	Tx_MessageStateKey = 61;  // key: x/messageHash; value: blkID, height, status
	TX_BlockKey = 62;         // key: x/blockHash; value: blk content, 
	Tx_HeightKey = 63;		  // key: x/blockHeight; value: blk hash	
}

//    =============  lfs information  ================

// 'SuperBlockInfoKey'/fsID
message SuperBlockInfo {
	uint32 Version      = 1;         
	uint32 ReplicaNum = 2;
	uint64 NextBucketID = 3;
}

// 'BucketCountKey'/fsID
// 'StripeCountKey'/fsID/bucketID
// key: 'BucketOptionKey'/fsID/bucketID
message BucketOption {
	uint32 Version = 1;
	uint32 Policy = 2;
	uint32 DataCount = 3;
	uint32 ParityCount = 4;
	uint32 TagFlag = 5;
	uint32 SegSize = 6;
} 

// key: 'BucketInfoKey'/fsID/bucketID
message BucketInfo {
	uint64 BucketID = 1;
	int64 CTime = 2;      // create time
	int64 MTime = 3;      // modify time
	uint64 Length = 4;     // data_count * segSize 
	uint64 UsedBytes = 5;  // chunk_count * (segSize + prefix + tagCount*tagSize)
	uint64 NextObjectID = 6;
	uint64 NextOpID = 7;  
	bool deletion = 8;
	string Name = 9;
	bytes Root = 10;  // merkle root of ops; used for verify
}

message ObjectForm {
	repeated uint64 OpRecord = 1;
}

// object information; when create object 
message ObjectInfo {
	uint64 ObjectID = 1;
	uint64 BucketID = 2;
	int64 Time = 3;  
	uint64 Expire = 4;
	string Name = 5;
	string Encryption = 6; // enc method
}

// object delete information; when delete object 
message ObjectDeleteInfo {
    uint64  ObjectID = 1;
    int64  Time     = 2;
}

// opart informations, insert into object when add data to an existing object
message ObjectPartInfo {
	uint64 ObjectID = 1;          // 此分块所属的ObjectID
	int64 Time = 2;               // append此Part的时间
	uint64 Offset = 3;            // offset in bucket space  
	uint64 Length = 4;            // mod stripeSize
	uint64 RawLength = 5;         // actual size of this part  
	bytes ETag = 7;               // MD5 of this part
}

// 'OpDoneKey'/fsID/bucketID
// 'OpCountKey'/fsID/bucketID
// key: 'OpInfoKey'/fsID/bucketID/opID
message OpRecord {
    enum OpType {
	    Unknown = 0; 
	    CreateObject = 1;     // create an object; payload is ObjectInfo
	    AddData = 2;          // add data to objec; payload is PartInfo
	    DeleteObject = 3;     // delete an object; payload is DeleteObject
    }

	OpType Type = 1;
	uint64 OpID = 2;
	int64 Time = 3;  // time of this op, need ?
	bytes Payload = 4;    
}

enum DataType {
    DataErr = 0;
    Segment = 1;
    Piece = 2;
    Sector = 3;
}

// key: 'SegLocKey'/fsID_bucketID_chunkID_stripeID
message SegLocation {
	uint64 Expire = 1;
	uint64 Length = 2;
	uint64 ProID = 3;
}

// key: 'SegExpireKey'/fsID_bucketID_stripeID
message SegExpire {
	uint64 Length = 1;
	uint64 Expire = 2; // expire time
}

// key: 'PieceLocKey'/pieceID; on keeper and user
message PieceLocation {
	uint32 Size = 1;
	uint64 Expire = 2;
	repeated uint64 ProID = 3; // 存在哪些provider上
}

// fsID need?
// key: 'PieceInfoKey'/pieceID; on provider
message PieceInfo {
	uint32 Offset = 1;   // offset in sector; 是否需要？ 
	uint32 Size = 2;
	uint64 Expire = 3;
	uint64 SectorID = 4;  // belong to which sector
}

// 'SectorCountKey'/proID; on keeper and provider
// 'SectorSetKey'/proID; on keeper and provider
// key: 'SectorInfoKey'/pieceID; on keeper, 70 bytes
message SectorInfo {
	uint64 Expire = 1;
	bytes CommD = 2; // 32bytes
	bytes CommR = 3; // 32bytes
}

// key: 'SectorPiecesKey'/sectorID; on provider
message SectorPieces {
	SectorInfo Sector = 1;
	repeated bytes PieceID = 2;
}